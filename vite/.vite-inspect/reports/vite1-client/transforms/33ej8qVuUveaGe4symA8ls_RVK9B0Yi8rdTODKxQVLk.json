{
  "resolvedId": "/Users/rwr/repo/vite/vite/node_modules/.pnpm/vite@7.0.0/node_modules/vite/dist/client/client.mjs",
  "transforms": [
    {
      "name": "__load__",
      "result": "import \"@vite/env\";\n\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/typeof.js\nfunction _typeof(o) {\n\t\"@babel/helpers - typeof\";\n\treturn _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\treturn typeof o$1;\n\t} : function(o$1) {\n\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t}, _typeof(o);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPrimitive.js\nfunction toPrimitive(t, r) {\n\tif (\"object\" != _typeof(t) || !t) return t;\n\tvar e = t[Symbol.toPrimitive];\n\tif (void 0 !== e) {\n\t\tvar i = e.call(t, r || \"default\");\n\t\tif (\"object\" != _typeof(i)) return i;\n\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t}\n\treturn (\"string\" === r ? String : Number)(t);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPropertyKey.js\nfunction toPropertyKey(t) {\n\tvar i = toPrimitive(t, \"string\");\n\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/defineProperty.js\nfunction _defineProperty(e, r, t) {\n\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\tvalue: t,\n\t\tenumerable: !0,\n\t\tconfigurable: !0,\n\t\twritable: !0\n\t}) : e[r] = t, e;\n}\n\n//#endregion\n//#region src/shared/hmr.ts\nvar HMRContext = class {\n\tconstructor(hmrClient$1, ownerPath) {\n\t\tthis.hmrClient = hmrClient$1;\n\t\tthis.ownerPath = ownerPath;\n\t\t_defineProperty(this, \"newListeners\", void 0);\n\t\tif (!hmrClient$1.dataMap.has(ownerPath)) hmrClient$1.dataMap.set(ownerPath, {});\n\t\tconst mod = hmrClient$1.hotModulesMap.get(ownerPath);\n\t\tif (mod) mod.callbacks = [];\n\t\tconst staleListeners = hmrClient$1.ctxToListenersMap.get(ownerPath);\n\t\tif (staleListeners) for (const [event, staleFns] of staleListeners) {\n\t\t\tconst listeners = hmrClient$1.customListenersMap.get(event);\n\t\t\tif (listeners) hmrClient$1.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n\t\t}\n\t\tthis.newListeners = /* @__PURE__ */ new Map();\n\t\thmrClient$1.ctxToListenersMap.set(ownerPath, this.newListeners);\n\t}\n\tget data() {\n\t\treturn this.hmrClient.dataMap.get(this.ownerPath);\n\t}\n\taccept(deps, callback) {\n\t\tif (typeof deps === \"function\" || !deps) this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n\t\telse if (typeof deps === \"string\") this.acceptDeps([deps], ([mod]) => callback?.(mod));\n\t\telse if (Array.isArray(deps)) this.acceptDeps(deps, callback);\n\t\telse throw new Error(`invalid hot.accept() usage.`);\n\t}\n\tacceptExports(_, callback) {\n\t\tthis.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n\t}\n\tdispose(cb) {\n\t\tthis.hmrClient.disposeMap.set(this.ownerPath, cb);\n\t}\n\tprune(cb) {\n\t\tthis.hmrClient.pruneMap.set(this.ownerPath, cb);\n\t}\n\tdecline() {}\n\tinvalidate(message) {\n\t\tconst firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n\t\tthis.hmrClient.notifyListeners(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.send(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.hmrClient.logger.debug(`invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`);\n\t}\n\ton(event, cb) {\n\t\tconst addToMap = (map) => {\n\t\t\tconst existing = map.get(event) || [];\n\t\t\texisting.push(cb);\n\t\t\tmap.set(event, existing);\n\t\t};\n\t\taddToMap(this.hmrClient.customListenersMap);\n\t\taddToMap(this.newListeners);\n\t}\n\toff(event, cb) {\n\t\tconst removeFromMap = (map) => {\n\t\t\tconst existing = map.get(event);\n\t\t\tif (existing === void 0) return;\n\t\t\tconst pruned = existing.filter((l) => l !== cb);\n\t\t\tif (pruned.length === 0) {\n\t\t\t\tmap.delete(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(event, pruned);\n\t\t};\n\t\tremoveFromMap(this.hmrClient.customListenersMap);\n\t\tremoveFromMap(this.newListeners);\n\t}\n\tsend(event, data) {\n\t\tthis.hmrClient.send({\n\t\t\ttype: \"custom\",\n\t\t\tevent,\n\t\t\tdata\n\t\t});\n\t}\n\tacceptDeps(deps, callback = () => {}) {\n\t\tconst mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n\t\t\tid: this.ownerPath,\n\t\t\tcallbacks: []\n\t\t};\n\t\tmod.callbacks.push({\n\t\t\tdeps,\n\t\t\tfn: callback\n\t\t});\n\t\tthis.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n\t}\n};\nvar HMRClient = class {\n\tconstructor(logger, transport$1, importUpdatedModule) {\n\t\tthis.logger = logger;\n\t\tthis.transport = transport$1;\n\t\tthis.importUpdatedModule = importUpdatedModule;\n\t\t_defineProperty(this, \"hotModulesMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"disposeMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"pruneMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"dataMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"customListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"ctxToListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"currentFirstInvalidatedBy\", void 0);\n\t\t_defineProperty(this, \"updateQueue\", []);\n\t\t_defineProperty(this, \"pendingUpdateQueue\", false);\n\t}\n\tasync notifyListeners(event, data) {\n\t\tconst cbs = this.customListenersMap.get(event);\n\t\tif (cbs) await Promise.allSettled(cbs.map((cb) => cb(data)));\n\t}\n\tsend(payload) {\n\t\tthis.transport.send(payload).catch((err) => {\n\t\t\tthis.logger.error(err);\n\t\t});\n\t}\n\tclear() {\n\t\tthis.hotModulesMap.clear();\n\t\tthis.disposeMap.clear();\n\t\tthis.pruneMap.clear();\n\t\tthis.dataMap.clear();\n\t\tthis.customListenersMap.clear();\n\t\tthis.ctxToListenersMap.clear();\n\t}\n\tasync prunePaths(paths) {\n\t\tawait Promise.all(paths.map((path) => {\n\t\t\tconst disposer = this.disposeMap.get(path);\n\t\t\tif (disposer) return disposer(this.dataMap.get(path));\n\t\t}));\n\t\tpaths.forEach((path) => {\n\t\t\tconst fn = this.pruneMap.get(path);\n\t\t\tif (fn) fn(this.dataMap.get(path));\n\t\t});\n\t}\n\twarnFailedUpdate(err, path) {\n\t\tif (!(err instanceof Error) || !err.message.includes(\"fetch\")) this.logger.error(err);\n\t\tthis.logger.error(`Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`);\n\t}\n\t/**\n\t* buffer multiple hot updates triggered by the same src change\n\t* so that they are invoked in the same order they were sent.\n\t* (otherwise the order may be inconsistent because of the http request round trip)\n\t*/\n\tasync queueUpdate(payload) {\n\t\tthis.updateQueue.push(this.fetchUpdate(payload));\n\t\tif (!this.pendingUpdateQueue) {\n\t\t\tthis.pendingUpdateQueue = true;\n\t\t\tawait Promise.resolve();\n\t\t\tthis.pendingUpdateQueue = false;\n\t\t\tconst loading = [...this.updateQueue];\n\t\t\tthis.updateQueue = [];\n\t\t\t(await Promise.all(loading)).forEach((fn) => fn && fn());\n\t\t}\n\t}\n\tasync fetchUpdate(update) {\n\t\tconst { path, acceptedPath, firstInvalidatedBy } = update;\n\t\tconst mod = this.hotModulesMap.get(path);\n\t\tif (!mod) return;\n\t\tlet fetchedModule;\n\t\tconst isSelfUpdate = path === acceptedPath;\n\t\tconst qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n\t\tif (isSelfUpdate || qualifiedCallbacks.length > 0) {\n\t\t\tconst disposer = this.disposeMap.get(acceptedPath);\n\t\t\tif (disposer) await disposer(this.dataMap.get(acceptedPath));\n\t\t\ttry {\n\t\t\t\tfetchedModule = await this.importUpdatedModule(update);\n\t\t\t} catch (e) {\n\t\t\t\tthis.warnFailedUpdate(e, acceptedPath);\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\ttry {\n\t\t\t\tthis.currentFirstInvalidatedBy = firstInvalidatedBy;\n\t\t\t\tfor (const { deps, fn } of qualifiedCallbacks) fn(deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0));\n\t\t\t\tconst loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n\t\t\t\tthis.logger.debug(`hot updated: ${loggedPath}`);\n\t\t\t} finally {\n\t\t\t\tthis.currentFirstInvalidatedBy = void 0;\n\t\t\t}\n\t\t};\n\t}\n};\n\n//#endregion\n//#region ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/non-secure/index.js\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet nanoid = (size = 21) => {\n\tlet id = \"\";\n\tlet i = size | 0;\n\twhile (i--) id += urlAlphabet[Math.random() * 64 | 0];\n\treturn id;\n};\n\n//#endregion\n//#region src/shared/constants.ts\nlet SOURCEMAPPING_URL = \"sourceMa\";\nSOURCEMAPPING_URL += \"ppingURL\";\n\n//#endregion\n//#region src/shared/utils.ts\nconst isWindows = typeof process !== \"undefined\" && process.platform === \"win32\";\nconst AsyncFunction = async function() {}.constructor;\nfunction promiseWithResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/shared/moduleRunnerTransport.ts\nfunction reviveInvokeError(e) {\n\tconst error = new Error(e.message || \"Unknown invoke error\");\n\tObject.assign(error, e, { runnerError: /* @__PURE__ */ new Error(\"RunnerError\") });\n\treturn error;\n}\nconst createInvokeableTransport = (transport$1) => {\n\tif (transport$1.invoke) return {\n\t\t...transport$1,\n\t\tasync invoke(name, data) {\n\t\t\tconst result = await transport$1.invoke({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tid: \"send\",\n\t\t\t\t\tname,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (\"error\" in result) throw reviveInvokeError(result.error);\n\t\t\treturn result.result;\n\t\t}\n\t};\n\tif (!transport$1.send || !transport$1.connect) throw new Error(\"transport must implement send and connect when invoke is not implemented\");\n\tconst rpcPromises = /* @__PURE__ */ new Map();\n\treturn {\n\t\t...transport$1,\n\t\tconnect({ onMessage, onDisconnection }) {\n\t\t\treturn transport$1.connect({\n\t\t\t\tonMessage(payload) {\n\t\t\t\t\tif (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n\t\t\t\t\t\tconst data = payload.data;\n\t\t\t\t\t\tif (data.id.startsWith(\"response:\")) {\n\t\t\t\t\t\t\tconst invokeId = data.id.slice(9);\n\t\t\t\t\t\t\tconst promise = rpcPromises.get(invokeId);\n\t\t\t\t\t\t\tif (!promise) return;\n\t\t\t\t\t\t\tif (promise.timeoutId) clearTimeout(promise.timeoutId);\n\t\t\t\t\t\t\trpcPromises.delete(invokeId);\n\t\t\t\t\t\t\tconst { error, result } = data.data;\n\t\t\t\t\t\t\tif (error) promise.reject(error);\n\t\t\t\t\t\t\telse promise.resolve(result);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tonMessage(payload);\n\t\t\t\t},\n\t\t\t\tonDisconnection\n\t\t\t});\n\t\t},\n\t\tdisconnect() {\n\t\t\trpcPromises.forEach((promise) => {\n\t\t\t\tpromise.reject(/* @__PURE__ */ new Error(`transport was disconnected, cannot call ${JSON.stringify(promise.name)}`));\n\t\t\t});\n\t\t\trpcPromises.clear();\n\t\t\treturn transport$1.disconnect?.();\n\t\t},\n\t\tsend(data) {\n\t\t\treturn transport$1.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tconst promiseId = nanoid();\n\t\t\tconst wrappedData = {\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tname,\n\t\t\t\t\tid: `send:${promiseId}`,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst sendPromise = transport$1.send(wrappedData);\n\t\t\tconst { promise, resolve, reject } = promiseWithResolvers();\n\t\t\tconst timeout = transport$1.timeout ?? 6e4;\n\t\t\tlet timeoutId;\n\t\t\tif (timeout > 0) {\n\t\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\t\treject(/* @__PURE__ */ new Error(`transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`));\n\t\t\t\t}, timeout);\n\t\t\t\ttimeoutId?.unref?.();\n\t\t\t}\n\t\t\trpcPromises.set(promiseId, {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\tname,\n\t\t\t\ttimeoutId\n\t\t\t});\n\t\t\tif (sendPromise) sendPromise.catch((err) => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\ttry {\n\t\t\t\treturn await promise;\n\t\t\t} catch (err) {\n\t\t\t\tthrow reviveInvokeError(err);\n\t\t\t}\n\t\t}\n\t};\n};\nconst normalizeModuleRunnerTransport = (transport$1) => {\n\tconst invokeableTransport = createInvokeableTransport(transport$1);\n\tlet isConnected = !invokeableTransport.connect;\n\tlet connectingPromise;\n\treturn {\n\t\t...transport$1,\n\t\t...invokeableTransport.connect ? { async connect(onMessage) {\n\t\t\tif (isConnected) return;\n\t\t\tif (connectingPromise) {\n\t\t\t\tawait connectingPromise;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst maybePromise = invokeableTransport.connect({\n\t\t\t\tonMessage: onMessage ?? (() => {}),\n\t\t\t\tonDisconnection() {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (maybePromise) {\n\t\t\t\tconnectingPromise = maybePromise;\n\t\t\t\tawait connectingPromise;\n\t\t\t\tconnectingPromise = void 0;\n\t\t\t}\n\t\t\tisConnected = true;\n\t\t} } : {},\n\t\t...invokeableTransport.disconnect ? { async disconnect() {\n\t\t\tif (!isConnected) return;\n\t\t\tif (connectingPromise) await connectingPromise;\n\t\t\tisConnected = false;\n\t\t\tawait invokeableTransport.disconnect();\n\t\t} } : {},\n\t\tasync send(data) {\n\t\t\tif (!invokeableTransport.send) return;\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"send was called before connect\");\n\t\t\tawait invokeableTransport.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"invoke was called before connect\");\n\t\t\treturn invokeableTransport.invoke(name, data);\n\t\t}\n\t};\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n\tconst pingInterval = options.pingInterval ?? 3e4;\n\tlet ws;\n\tlet pingIntervalId;\n\treturn {\n\t\tasync connect({ onMessage, onDisconnection }) {\n\t\t\tconst socket = options.createConnection();\n\t\t\tsocket.addEventListener(\"message\", async ({ data }) => {\n\t\t\t\tonMessage(JSON.parse(data));\n\t\t\t});\n\t\t\tlet isOpened = socket.readyState === socket.OPEN;\n\t\t\tif (!isOpened) await new Promise((resolve, reject) => {\n\t\t\t\tsocket.addEventListener(\"open\", () => {\n\t\t\t\t\tisOpened = true;\n\t\t\t\t\tresolve();\n\t\t\t\t}, { once: true });\n\t\t\t\tsocket.addEventListener(\"close\", async () => {\n\t\t\t\t\tif (!isOpened) {\n\t\t\t\t\t\treject(/* @__PURE__ */ new Error(\"WebSocket closed without opened.\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonMessage({\n\t\t\t\t\t\ttype: \"custom\",\n\t\t\t\t\t\tevent: \"vite:ws:disconnect\",\n\t\t\t\t\t\tdata: { webSocket: socket }\n\t\t\t\t\t});\n\t\t\t\t\tonDisconnection();\n\t\t\t\t});\n\t\t\t});\n\t\t\tonMessage({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:ws:connect\",\n\t\t\t\tdata: { webSocket: socket }\n\t\t\t});\n\t\t\tws = socket;\n\t\t\tpingIntervalId = setInterval(() => {\n\t\t\t\tif (socket.readyState === socket.OPEN) socket.send(JSON.stringify({ type: \"ping\" }));\n\t\t\t}, pingInterval);\n\t\t},\n\t\tdisconnect() {\n\t\t\tclearInterval(pingIntervalId);\n\t\t\tws?.close();\n\t\t},\n\t\tsend(data) {\n\t\t\tws.send(JSON.stringify(data));\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/shared/hmrHandler.ts\nfunction createHMRHandler(handler) {\n\tconst queue = new Queue();\n\treturn (payload) => queue.enqueue(() => handler(payload));\n}\nvar Queue = class {\n\tconstructor() {\n\t\t_defineProperty(this, \"queue\", []);\n\t\t_defineProperty(this, \"pending\", false);\n\t}\n\tenqueue(promise) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.queue.push({\n\t\t\t\tpromise,\n\t\t\t\tresolve,\n\t\t\t\treject\n\t\t\t});\n\t\t\tthis.dequeue();\n\t\t});\n\t}\n\tdequeue() {\n\t\tif (this.pending) return false;\n\t\tconst item = this.queue.shift();\n\t\tif (!item) return false;\n\t\tthis.pending = true;\n\t\titem.promise().then(item.resolve).catch(item.reject).finally(() => {\n\t\t\tthis.pending = false;\n\t\t\tthis.dequeue();\n\t\t});\n\t\treturn true;\n\t}\n};\n\n//#endregion\n//#region src/client/overlay.ts\nconst hmrConfigName = __HMR_CONFIG_NAME__;\nconst base$1 = __BASE__ || \"/\";\nfunction h(e, attrs = {}, ...children) {\n\tconst elem = document.createElement(e);\n\tfor (const [k, v] of Object.entries(attrs)) elem.setAttribute(k, v);\n\telem.append(...children);\n\treturn elem;\n}\nconst templateStyle = `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\nconst createTemplate = () => h(\"div\", {\n\tclass: \"backdrop\",\n\tpart: \"backdrop\"\n}, h(\"div\", {\n\tclass: \"window\",\n\tpart: \"window\"\n}, h(\"pre\", {\n\tclass: \"message\",\n\tpart: \"message\"\n}, h(\"span\", {\n\tclass: \"plugin\",\n\tpart: \"plugin\"\n}), h(\"span\", {\n\tclass: \"message-body\",\n\tpart: \"message-body\"\n})), h(\"pre\", {\n\tclass: \"file\",\n\tpart: \"file\"\n}), h(\"pre\", {\n\tclass: \"frame\",\n\tpart: \"frame\"\n}), h(\"pre\", {\n\tclass: \"stack\",\n\tpart: \"stack\"\n}), h(\"div\", {\n\tclass: \"tip\",\n\tpart: \"tip\"\n}, \"Click outside, press \", h(\"kbd\", {}, \"Esc\"), \" key, or fix the code to dismiss.\", h(\"br\"), \"You can also disable this overlay by setting \", h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"), \" to \", h(\"code\", { part: \"config-option-value\" }, \"false\"), \" in \", h(\"code\", { part: \"config-file-name\" }, hmrConfigName), \".\")), h(\"style\", {}, templateStyle));\nconst fileRE = /(?:file:\\/\\/)?(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {} } = globalThis;\nvar ErrorOverlay = class extends HTMLElement {\n\tconstructor(err, links = true) {\n\t\tsuper();\n\t\t_defineProperty(this, \"root\", void 0);\n\t\t_defineProperty(this, \"closeOnEsc\", void 0);\n\t\tthis.root = this.attachShadow({ mode: \"open\" });\n\t\tthis.root.appendChild(createTemplate());\n\t\tcodeframeRE.lastIndex = 0;\n\t\tconst hasFrame = err.frame && codeframeRE.test(err.frame);\n\t\tconst message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n\t\tif (err.plugin) this.text(\".plugin\", `[plugin:${err.plugin}] `);\n\t\tthis.text(\".message-body\", message.trim());\n\t\tconst [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n\t\tif (err.loc) this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n\t\telse if (err.id) this.text(\".file\", file);\n\t\tif (hasFrame) this.text(\".frame\", err.frame.trim());\n\t\tthis.text(\".stack\", err.stack, links);\n\t\tthis.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n\t\t\te.stopPropagation();\n\t\t});\n\t\tthis.addEventListener(\"click\", () => {\n\t\t\tthis.close();\n\t\t});\n\t\tthis.closeOnEsc = (e) => {\n\t\t\tif (e.key === \"Escape\" || e.code === \"Escape\") this.close();\n\t\t};\n\t\tdocument.addEventListener(\"keydown\", this.closeOnEsc);\n\t}\n\ttext(selector, text, linkFiles = false) {\n\t\tconst el = this.root.querySelector(selector);\n\t\tif (!linkFiles) el.textContent = text;\n\t\telse {\n\t\t\tlet curIndex = 0;\n\t\t\tlet match;\n\t\t\tfileRE.lastIndex = 0;\n\t\t\twhile (match = fileRE.exec(text)) {\n\t\t\t\tconst { 0: file, index } = match;\n\t\t\t\tconst frag = text.slice(curIndex, index);\n\t\t\t\tel.appendChild(document.createTextNode(frag));\n\t\t\t\tconst link = document.createElement(\"a\");\n\t\t\t\tlink.textContent = file;\n\t\t\t\tlink.className = \"file-link\";\n\t\t\t\tlink.onclick = () => {\n\t\t\t\t\tfetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n\t\t\t\t};\n\t\t\t\tel.appendChild(link);\n\t\t\t\tcurIndex += frag.length + file.length;\n\t\t\t}\n\t\t\tif (curIndex < text.length) el.appendChild(document.createTextNode(text.slice(curIndex)));\n\t\t}\n\t}\n\tclose() {\n\t\tthis.parentNode?.removeChild(this);\n\t\tdocument.removeEventListener(\"keydown\", this.closeOnEsc);\n\t}\n};\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) customElements.define(overlayId, ErrorOverlay);\n\n//#endregion\n//#region src/client/client.ts\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || \"/\";\nconst hmrTimeout = __HMR_TIMEOUT__;\nconst wsToken = __WS_TOKEN__;\nconst transport = normalizeModuleRunnerTransport((() => {\n\tlet wsTransport = createWebSocketModuleRunnerTransport({\n\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${socketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\tpingInterval: hmrTimeout\n\t});\n\treturn {\n\t\tasync connect(handlers) {\n\t\t\ttry {\n\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t} catch (e) {\n\t\t\t\tif (!hmrPort) {\n\t\t\t\t\twsTransport = createWebSocketModuleRunnerTransport({\n\t\t\t\t\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${directSocketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\t\t\t\t\tpingInterval: hmrTimeout\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t\t\t\tconsole.info(\"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\");\n\t\t\t\t\t} catch (e$1) {\n\t\t\t\t\t\tif (e$1 instanceof Error && e$1.message.includes(\"WebSocket closed without opened.\")) {\n\t\t\t\t\t\t\tconst currentScriptHostURL = new URL(import.meta.url);\n\t\t\t\t\t\t\tconst currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n\t\t\t\t\t\t\tconsole.error(`[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.error(`[vite] failed to connect to websocket (${e}). `);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\t\tasync disconnect() {\n\t\t\tawait wsTransport.disconnect();\n\t\t},\n\t\tsend(data) {\n\t\t\twsTransport.send(data);\n\t\t}\n\t};\n})());\nlet willUnload = false;\nif (typeof window !== \"undefined\") window.addEventListener(\"beforeunload\", () => {\n\twillUnload = true;\n});\nfunction cleanUrl(pathname) {\n\tconst url = new URL(pathname, \"http://vite.dev\");\n\turl.searchParams.delete(\"direct\");\n\treturn url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n\tlet timer;\n\treturn () => {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\t\ttimer = setTimeout(() => {\n\t\t\tlocation.reload();\n\t\t}, time);\n\t};\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient({\n\terror: (err) => console.error(\"[vite]\", err),\n\tdebug: (...msg) => console.debug(\"[vite]\", ...msg)\n}, transport, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport }) {\n\tconst [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n\tconst importPromise = import(\n\t/* @vite-ignore */\n\tbase + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`);\n\tif (isWithinCircularImport) importPromise.catch(() => {\n\t\tconsole.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n\t\tpageReload();\n\t});\n\treturn await importPromise;\n});\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n\tswitch (payload.type) {\n\t\tcase \"connected\":\n\t\t\tconsole.debug(`[vite] connected.`);\n\t\t\tbreak;\n\t\tcase \"update\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n\t\t\tif (hasDocument) if (isFirstUpdate && hasErrorOverlay()) {\n\t\t\t\tlocation.reload();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (enableOverlay) clearErrorOverlay();\n\t\t\t\tisFirstUpdate = false;\n\t\t\t}\n\t\t\tawait Promise.all(payload.updates.map(async (update) => {\n\t\t\t\tif (update.type === \"js-update\") return hmrClient.queueUpdate(update);\n\t\t\t\tconst { path, timestamp } = update;\n\t\t\t\tconst searchUrl = cleanUrl(path);\n\t\t\t\tconst el = Array.from(document.querySelectorAll(\"link\")).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n\t\t\t\tif (!el) return;\n\t\t\t\tconst newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tconst newLinkTag = el.cloneNode();\n\t\t\t\t\tnewLinkTag.href = new URL(newPath, el.href).href;\n\t\t\t\t\tconst removeOldEl = () => {\n\t\t\t\t\t\tel.remove();\n\t\t\t\t\t\tconsole.debug(`[vite] css hot updated: ${searchUrl}`);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t};\n\t\t\t\t\tnewLinkTag.addEventListener(\"load\", removeOldEl);\n\t\t\t\t\tnewLinkTag.addEventListener(\"error\", removeOldEl);\n\t\t\t\t\toutdatedLinkTags.add(el);\n\t\t\t\t\tel.after(newLinkTag);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tawait hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n\t\t\tbreak;\n\t\tcase \"custom\": {\n\t\t\tawait hmrClient.notifyListeners(payload.event, payload.data);\n\t\t\tif (payload.event === \"vite:ws:disconnect\") {\n\t\t\t\tif (hasDocument && !willUnload) {\n\t\t\t\t\tconsole.log(`[vite] server connection lost. Polling for restart...`);\n\t\t\t\t\tconst socket = payload.data.webSocket;\n\t\t\t\t\tconst url = new URL(socket.url);\n\t\t\t\t\turl.search = \"\";\n\t\t\t\t\tawait waitForSuccessfulPing(url.href);\n\t\t\t\t\tlocation.reload();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"full-reload\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n\t\t\tif (hasDocument) if (payload.path && payload.path.endsWith(\".html\")) {\n\t\t\t\tconst pagePath = decodeURI(location.pathname);\n\t\t\t\tconst payloadPath = base + payload.path.slice(1);\n\t\t\t\tif (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) pageReload();\n\t\t\t\treturn;\n\t\t\t} else pageReload();\n\t\t\tbreak;\n\t\tcase \"prune\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n\t\t\tawait hmrClient.prunePaths(payload.paths);\n\t\t\tbreak;\n\t\tcase \"error\": {\n\t\t\tawait hmrClient.notifyListeners(\"vite:error\", payload);\n\t\t\tif (hasDocument) {\n\t\t\t\tconst err = payload.err;\n\t\t\t\tif (enableOverlay) createErrorOverlay(err);\n\t\t\t\telse console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"ping\": break;\n\t\tdefault: {\n\t\t\tconst check = payload;\n\t\t\treturn check;\n\t\t}\n\t}\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n\tclearErrorOverlay();\n\tconst { customElements: customElements$1 } = globalThis;\n\tif (customElements$1) {\n\t\tconst ErrorOverlayConstructor = customElements$1.get(overlayId);\n\t\tdocument.body.appendChild(new ErrorOverlayConstructor(err));\n\t}\n}\nfunction clearErrorOverlay() {\n\tdocument.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n\treturn document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n\tasync function ping() {\n\t\tconst socket = new WebSocket(socketUrl, \"vite-ping\");\n\t\treturn new Promise((resolve) => {\n\t\t\tfunction onOpen() {\n\t\t\t\tresolve(true);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction onError() {\n\t\t\t\tresolve(false);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction close() {\n\t\t\t\tsocket.removeEventListener(\"open\", onOpen);\n\t\t\t\tsocket.removeEventListener(\"error\", onError);\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t\tsocket.addEventListener(\"open\", onOpen);\n\t\t\tsocket.addEventListener(\"error\", onError);\n\t\t});\n\t}\n\tif (await ping()) return;\n\tawait wait(ms);\n\twhile (true) if (document.visibilityState === \"visible\") {\n\t\tif (await ping()) break;\n\t\tawait wait(ms);\n\t} else await waitForWindowShow();\n}\nfunction wait(ms) {\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n\treturn new Promise((resolve) => {\n\t\tconst onChange = async () => {\n\t\t\tif (document.visibilityState === \"visible\") {\n\t\t\t\tresolve();\n\t\t\t\tdocument.removeEventListener(\"visibilitychange\", onChange);\n\t\t\t}\n\t\t};\n\t\tdocument.addEventListener(\"visibilitychange\", onChange);\n\t});\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n\tsheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n});\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n\tlet style = sheetsMap.get(id);\n\tif (!style) {\n\t\tstyle = document.createElement(\"style\");\n\t\tstyle.setAttribute(\"type\", \"text/css\");\n\t\tstyle.setAttribute(\"data-vite-dev-id\", id);\n\t\tstyle.textContent = content;\n\t\tif (cspNonce) style.setAttribute(\"nonce\", cspNonce);\n\t\tif (!lastInsertedStyle) {\n\t\t\tdocument.head.appendChild(style);\n\t\t\tsetTimeout(() => {\n\t\t\t\tlastInsertedStyle = void 0;\n\t\t\t}, 0);\n\t\t} else lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n\t\tlastInsertedStyle = style;\n\t} else style.textContent = content;\n\tsheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n\tconst style = sheetsMap.get(id);\n\tif (style) {\n\t\tdocument.head.removeChild(style);\n\t\tsheetsMap.delete(id);\n\t}\n}\nfunction createHotContext(ownerPath) {\n\treturn new HMRContext(hmrClient, ownerPath);\n}\n/**\n* urls here are dynamic import() urls that couldn't be statically analyzed\n*/\nfunction injectQuery(url, queryToInject) {\n\tif (url[0] !== \".\" && url[0] !== \"/\") return url;\n\tconst pathname = url.replace(/[?#].*$/, \"\");\n\tconst { search, hash } = new URL(url, \"http://vite.dev\");\n\treturn `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\n//#endregion\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };",
      "start": 1751213799880,
      "end": 1751213799880
    },
    {
      "name": "vite:css",
      "start": 1751213799880,
      "end": 1751213799880,
      "order": "normal-normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1751213799880,
      "end": 1751213799880,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1751213799880,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite-hooks-logger",
      "result": "import \"@vite/env\";\n\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/typeof.js\nfunction _typeof(o) {\n\t\"@babel/helpers - typeof\";\n\treturn _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\treturn typeof o$1;\n\t} : function(o$1) {\n\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t}, _typeof(o);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPrimitive.js\nfunction toPrimitive(t, r) {\n\tif (\"object\" != _typeof(t) || !t) return t;\n\tvar e = t[Symbol.toPrimitive];\n\tif (void 0 !== e) {\n\t\tvar i = e.call(t, r || \"default\");\n\t\tif (\"object\" != _typeof(i)) return i;\n\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t}\n\treturn (\"string\" === r ? String : Number)(t);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPropertyKey.js\nfunction toPropertyKey(t) {\n\tvar i = toPrimitive(t, \"string\");\n\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/defineProperty.js\nfunction _defineProperty(e, r, t) {\n\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\tvalue: t,\n\t\tenumerable: !0,\n\t\tconfigurable: !0,\n\t\twritable: !0\n\t}) : e[r] = t, e;\n}\n\n//#endregion\n//#region src/shared/hmr.ts\nvar HMRContext = class {\n\tconstructor(hmrClient$1, ownerPath) {\n\t\tthis.hmrClient = hmrClient$1;\n\t\tthis.ownerPath = ownerPath;\n\t\t_defineProperty(this, \"newListeners\", void 0);\n\t\tif (!hmrClient$1.dataMap.has(ownerPath)) hmrClient$1.dataMap.set(ownerPath, {});\n\t\tconst mod = hmrClient$1.hotModulesMap.get(ownerPath);\n\t\tif (mod) mod.callbacks = [];\n\t\tconst staleListeners = hmrClient$1.ctxToListenersMap.get(ownerPath);\n\t\tif (staleListeners) for (const [event, staleFns] of staleListeners) {\n\t\t\tconst listeners = hmrClient$1.customListenersMap.get(event);\n\t\t\tif (listeners) hmrClient$1.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n\t\t}\n\t\tthis.newListeners = /* @__PURE__ */ new Map();\n\t\thmrClient$1.ctxToListenersMap.set(ownerPath, this.newListeners);\n\t}\n\tget data() {\n\t\treturn this.hmrClient.dataMap.get(this.ownerPath);\n\t}\n\taccept(deps, callback) {\n\t\tif (typeof deps === \"function\" || !deps) this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n\t\telse if (typeof deps === \"string\") this.acceptDeps([deps], ([mod]) => callback?.(mod));\n\t\telse if (Array.isArray(deps)) this.acceptDeps(deps, callback);\n\t\telse throw new Error(`invalid hot.accept() usage.`);\n\t}\n\tacceptExports(_, callback) {\n\t\tthis.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n\t}\n\tdispose(cb) {\n\t\tthis.hmrClient.disposeMap.set(this.ownerPath, cb);\n\t}\n\tprune(cb) {\n\t\tthis.hmrClient.pruneMap.set(this.ownerPath, cb);\n\t}\n\tdecline() {}\n\tinvalidate(message) {\n\t\tconst firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n\t\tthis.hmrClient.notifyListeners(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.send(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.hmrClient.logger.debug(`invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`);\n\t}\n\ton(event, cb) {\n\t\tconst addToMap = (map) => {\n\t\t\tconst existing = map.get(event) || [];\n\t\t\texisting.push(cb);\n\t\t\tmap.set(event, existing);\n\t\t};\n\t\taddToMap(this.hmrClient.customListenersMap);\n\t\taddToMap(this.newListeners);\n\t}\n\toff(event, cb) {\n\t\tconst removeFromMap = (map) => {\n\t\t\tconst existing = map.get(event);\n\t\t\tif (existing === void 0) return;\n\t\t\tconst pruned = existing.filter((l) => l !== cb);\n\t\t\tif (pruned.length === 0) {\n\t\t\t\tmap.delete(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(event, pruned);\n\t\t};\n\t\tremoveFromMap(this.hmrClient.customListenersMap);\n\t\tremoveFromMap(this.newListeners);\n\t}\n\tsend(event, data) {\n\t\tthis.hmrClient.send({\n\t\t\ttype: \"custom\",\n\t\t\tevent,\n\t\t\tdata\n\t\t});\n\t}\n\tacceptDeps(deps, callback = () => {}) {\n\t\tconst mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n\t\t\tid: this.ownerPath,\n\t\t\tcallbacks: []\n\t\t};\n\t\tmod.callbacks.push({\n\t\t\tdeps,\n\t\t\tfn: callback\n\t\t});\n\t\tthis.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n\t}\n};\nvar HMRClient = class {\n\tconstructor(logger, transport$1, importUpdatedModule) {\n\t\tthis.logger = logger;\n\t\tthis.transport = transport$1;\n\t\tthis.importUpdatedModule = importUpdatedModule;\n\t\t_defineProperty(this, \"hotModulesMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"disposeMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"pruneMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"dataMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"customListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"ctxToListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"currentFirstInvalidatedBy\", void 0);\n\t\t_defineProperty(this, \"updateQueue\", []);\n\t\t_defineProperty(this, \"pendingUpdateQueue\", false);\n\t}\n\tasync notifyListeners(event, data) {\n\t\tconst cbs = this.customListenersMap.get(event);\n\t\tif (cbs) await Promise.allSettled(cbs.map((cb) => cb(data)));\n\t}\n\tsend(payload) {\n\t\tthis.transport.send(payload).catch((err) => {\n\t\t\tthis.logger.error(err);\n\t\t});\n\t}\n\tclear() {\n\t\tthis.hotModulesMap.clear();\n\t\tthis.disposeMap.clear();\n\t\tthis.pruneMap.clear();\n\t\tthis.dataMap.clear();\n\t\tthis.customListenersMap.clear();\n\t\tthis.ctxToListenersMap.clear();\n\t}\n\tasync prunePaths(paths) {\n\t\tawait Promise.all(paths.map((path) => {\n\t\t\tconst disposer = this.disposeMap.get(path);\n\t\t\tif (disposer) return disposer(this.dataMap.get(path));\n\t\t}));\n\t\tpaths.forEach((path) => {\n\t\t\tconst fn = this.pruneMap.get(path);\n\t\t\tif (fn) fn(this.dataMap.get(path));\n\t\t});\n\t}\n\twarnFailedUpdate(err, path) {\n\t\tif (!(err instanceof Error) || !err.message.includes(\"fetch\")) this.logger.error(err);\n\t\tthis.logger.error(`Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`);\n\t}\n\t/**\n\t* buffer multiple hot updates triggered by the same src change\n\t* so that they are invoked in the same order they were sent.\n\t* (otherwise the order may be inconsistent because of the http request round trip)\n\t*/\n\tasync queueUpdate(payload) {\n\t\tthis.updateQueue.push(this.fetchUpdate(payload));\n\t\tif (!this.pendingUpdateQueue) {\n\t\t\tthis.pendingUpdateQueue = true;\n\t\t\tawait Promise.resolve();\n\t\t\tthis.pendingUpdateQueue = false;\n\t\t\tconst loading = [...this.updateQueue];\n\t\t\tthis.updateQueue = [];\n\t\t\t(await Promise.all(loading)).forEach((fn) => fn && fn());\n\t\t}\n\t}\n\tasync fetchUpdate(update) {\n\t\tconst { path, acceptedPath, firstInvalidatedBy } = update;\n\t\tconst mod = this.hotModulesMap.get(path);\n\t\tif (!mod) return;\n\t\tlet fetchedModule;\n\t\tconst isSelfUpdate = path === acceptedPath;\n\t\tconst qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n\t\tif (isSelfUpdate || qualifiedCallbacks.length > 0) {\n\t\t\tconst disposer = this.disposeMap.get(acceptedPath);\n\t\t\tif (disposer) await disposer(this.dataMap.get(acceptedPath));\n\t\t\ttry {\n\t\t\t\tfetchedModule = await this.importUpdatedModule(update);\n\t\t\t} catch (e) {\n\t\t\t\tthis.warnFailedUpdate(e, acceptedPath);\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\ttry {\n\t\t\t\tthis.currentFirstInvalidatedBy = firstInvalidatedBy;\n\t\t\t\tfor (const { deps, fn } of qualifiedCallbacks) fn(deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0));\n\t\t\t\tconst loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n\t\t\t\tthis.logger.debug(`hot updated: ${loggedPath}`);\n\t\t\t} finally {\n\t\t\t\tthis.currentFirstInvalidatedBy = void 0;\n\t\t\t}\n\t\t};\n\t}\n};\n\n//#endregion\n//#region ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/non-secure/index.js\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet nanoid = (size = 21) => {\n\tlet id = \"\";\n\tlet i = size | 0;\n\twhile (i--) id += urlAlphabet[Math.random() * 64 | 0];\n\treturn id;\n};\n\n//#endregion\n//#region src/shared/constants.ts\nlet SOURCEMAPPING_URL = \"sourceMa\";\nSOURCEMAPPING_URL += \"ppingURL\";\n\n//#endregion\n//#region src/shared/utils.ts\nconst isWindows = typeof process !== \"undefined\" && process.platform === \"win32\";\nconst AsyncFunction = async function() {}.constructor;\nfunction promiseWithResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/shared/moduleRunnerTransport.ts\nfunction reviveInvokeError(e) {\n\tconst error = new Error(e.message || \"Unknown invoke error\");\n\tObject.assign(error, e, { runnerError: /* @__PURE__ */ new Error(\"RunnerError\") });\n\treturn error;\n}\nconst createInvokeableTransport = (transport$1) => {\n\tif (transport$1.invoke) return {\n\t\t...transport$1,\n\t\tasync invoke(name, data) {\n\t\t\tconst result = await transport$1.invoke({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tid: \"send\",\n\t\t\t\t\tname,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (\"error\" in result) throw reviveInvokeError(result.error);\n\t\t\treturn result.result;\n\t\t}\n\t};\n\tif (!transport$1.send || !transport$1.connect) throw new Error(\"transport must implement send and connect when invoke is not implemented\");\n\tconst rpcPromises = /* @__PURE__ */ new Map();\n\treturn {\n\t\t...transport$1,\n\t\tconnect({ onMessage, onDisconnection }) {\n\t\t\treturn transport$1.connect({\n\t\t\t\tonMessage(payload) {\n\t\t\t\t\tif (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n\t\t\t\t\t\tconst data = payload.data;\n\t\t\t\t\t\tif (data.id.startsWith(\"response:\")) {\n\t\t\t\t\t\t\tconst invokeId = data.id.slice(9);\n\t\t\t\t\t\t\tconst promise = rpcPromises.get(invokeId);\n\t\t\t\t\t\t\tif (!promise) return;\n\t\t\t\t\t\t\tif (promise.timeoutId) clearTimeout(promise.timeoutId);\n\t\t\t\t\t\t\trpcPromises.delete(invokeId);\n\t\t\t\t\t\t\tconst { error, result } = data.data;\n\t\t\t\t\t\t\tif (error) promise.reject(error);\n\t\t\t\t\t\t\telse promise.resolve(result);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tonMessage(payload);\n\t\t\t\t},\n\t\t\t\tonDisconnection\n\t\t\t});\n\t\t},\n\t\tdisconnect() {\n\t\t\trpcPromises.forEach((promise) => {\n\t\t\t\tpromise.reject(/* @__PURE__ */ new Error(`transport was disconnected, cannot call ${JSON.stringify(promise.name)}`));\n\t\t\t});\n\t\t\trpcPromises.clear();\n\t\t\treturn transport$1.disconnect?.();\n\t\t},\n\t\tsend(data) {\n\t\t\treturn transport$1.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tconst promiseId = nanoid();\n\t\t\tconst wrappedData = {\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tname,\n\t\t\t\t\tid: `send:${promiseId}`,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst sendPromise = transport$1.send(wrappedData);\n\t\t\tconst { promise, resolve, reject } = promiseWithResolvers();\n\t\t\tconst timeout = transport$1.timeout ?? 6e4;\n\t\t\tlet timeoutId;\n\t\t\tif (timeout > 0) {\n\t\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\t\treject(/* @__PURE__ */ new Error(`transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`));\n\t\t\t\t}, timeout);\n\t\t\t\ttimeoutId?.unref?.();\n\t\t\t}\n\t\t\trpcPromises.set(promiseId, {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\tname,\n\t\t\t\ttimeoutId\n\t\t\t});\n\t\t\tif (sendPromise) sendPromise.catch((err) => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\ttry {\n\t\t\t\treturn await promise;\n\t\t\t} catch (err) {\n\t\t\t\tthrow reviveInvokeError(err);\n\t\t\t}\n\t\t}\n\t};\n};\nconst normalizeModuleRunnerTransport = (transport$1) => {\n\tconst invokeableTransport = createInvokeableTransport(transport$1);\n\tlet isConnected = !invokeableTransport.connect;\n\tlet connectingPromise;\n\treturn {\n\t\t...transport$1,\n\t\t...invokeableTransport.connect ? { async connect(onMessage) {\n\t\t\tif (isConnected) return;\n\t\t\tif (connectingPromise) {\n\t\t\t\tawait connectingPromise;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst maybePromise = invokeableTransport.connect({\n\t\t\t\tonMessage: onMessage ?? (() => {}),\n\t\t\t\tonDisconnection() {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (maybePromise) {\n\t\t\t\tconnectingPromise = maybePromise;\n\t\t\t\tawait connectingPromise;\n\t\t\t\tconnectingPromise = void 0;\n\t\t\t}\n\t\t\tisConnected = true;\n\t\t} } : {},\n\t\t...invokeableTransport.disconnect ? { async disconnect() {\n\t\t\tif (!isConnected) return;\n\t\t\tif (connectingPromise) await connectingPromise;\n\t\t\tisConnected = false;\n\t\t\tawait invokeableTransport.disconnect();\n\t\t} } : {},\n\t\tasync send(data) {\n\t\t\tif (!invokeableTransport.send) return;\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"send was called before connect\");\n\t\t\tawait invokeableTransport.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"invoke was called before connect\");\n\t\t\treturn invokeableTransport.invoke(name, data);\n\t\t}\n\t};\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n\tconst pingInterval = options.pingInterval ?? 3e4;\n\tlet ws;\n\tlet pingIntervalId;\n\treturn {\n\t\tasync connect({ onMessage, onDisconnection }) {\n\t\t\tconst socket = options.createConnection();\n\t\t\tsocket.addEventListener(\"message\", async ({ data }) => {\n\t\t\t\tonMessage(JSON.parse(data));\n\t\t\t});\n\t\t\tlet isOpened = socket.readyState === socket.OPEN;\n\t\t\tif (!isOpened) await new Promise((resolve, reject) => {\n\t\t\t\tsocket.addEventListener(\"open\", () => {\n\t\t\t\t\tisOpened = true;\n\t\t\t\t\tresolve();\n\t\t\t\t}, { once: true });\n\t\t\t\tsocket.addEventListener(\"close\", async () => {\n\t\t\t\t\tif (!isOpened) {\n\t\t\t\t\t\treject(/* @__PURE__ */ new Error(\"WebSocket closed without opened.\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonMessage({\n\t\t\t\t\t\ttype: \"custom\",\n\t\t\t\t\t\tevent: \"vite:ws:disconnect\",\n\t\t\t\t\t\tdata: { webSocket: socket }\n\t\t\t\t\t});\n\t\t\t\t\tonDisconnection();\n\t\t\t\t});\n\t\t\t});\n\t\t\tonMessage({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:ws:connect\",\n\t\t\t\tdata: { webSocket: socket }\n\t\t\t});\n\t\t\tws = socket;\n\t\t\tpingIntervalId = setInterval(() => {\n\t\t\t\tif (socket.readyState === socket.OPEN) socket.send(JSON.stringify({ type: \"ping\" }));\n\t\t\t}, pingInterval);\n\t\t},\n\t\tdisconnect() {\n\t\t\tclearInterval(pingIntervalId);\n\t\t\tws?.close();\n\t\t},\n\t\tsend(data) {\n\t\t\tws.send(JSON.stringify(data));\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/shared/hmrHandler.ts\nfunction createHMRHandler(handler) {\n\tconst queue = new Queue();\n\treturn (payload) => queue.enqueue(() => handler(payload));\n}\nvar Queue = class {\n\tconstructor() {\n\t\t_defineProperty(this, \"queue\", []);\n\t\t_defineProperty(this, \"pending\", false);\n\t}\n\tenqueue(promise) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.queue.push({\n\t\t\t\tpromise,\n\t\t\t\tresolve,\n\t\t\t\treject\n\t\t\t});\n\t\t\tthis.dequeue();\n\t\t});\n\t}\n\tdequeue() {\n\t\tif (this.pending) return false;\n\t\tconst item = this.queue.shift();\n\t\tif (!item) return false;\n\t\tthis.pending = true;\n\t\titem.promise().then(item.resolve).catch(item.reject).finally(() => {\n\t\t\tthis.pending = false;\n\t\t\tthis.dequeue();\n\t\t});\n\t\treturn true;\n\t}\n};\n\n//#endregion\n//#region src/client/overlay.ts\nconst hmrConfigName = __HMR_CONFIG_NAME__;\nconst base$1 = __BASE__ || \"/\";\nfunction h(e, attrs = {}, ...children) {\n\tconst elem = document.createElement(e);\n\tfor (const [k, v] of Object.entries(attrs)) elem.setAttribute(k, v);\n\telem.append(...children);\n\treturn elem;\n}\nconst templateStyle = `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\nconst createTemplate = () => h(\"div\", {\n\tclass: \"backdrop\",\n\tpart: \"backdrop\"\n}, h(\"div\", {\n\tclass: \"window\",\n\tpart: \"window\"\n}, h(\"pre\", {\n\tclass: \"message\",\n\tpart: \"message\"\n}, h(\"span\", {\n\tclass: \"plugin\",\n\tpart: \"plugin\"\n}), h(\"span\", {\n\tclass: \"message-body\",\n\tpart: \"message-body\"\n})), h(\"pre\", {\n\tclass: \"file\",\n\tpart: \"file\"\n}), h(\"pre\", {\n\tclass: \"frame\",\n\tpart: \"frame\"\n}), h(\"pre\", {\n\tclass: \"stack\",\n\tpart: \"stack\"\n}), h(\"div\", {\n\tclass: \"tip\",\n\tpart: \"tip\"\n}, \"Click outside, press \", h(\"kbd\", {}, \"Esc\"), \" key, or fix the code to dismiss.\", h(\"br\"), \"You can also disable this overlay by setting \", h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"), \" to \", h(\"code\", { part: \"config-option-value\" }, \"false\"), \" in \", h(\"code\", { part: \"config-file-name\" }, hmrConfigName), \".\")), h(\"style\", {}, templateStyle));\nconst fileRE = /(?:file:\\/\\/)?(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {} } = globalThis;\nvar ErrorOverlay = class extends HTMLElement {\n\tconstructor(err, links = true) {\n\t\tsuper();\n\t\t_defineProperty(this, \"root\", void 0);\n\t\t_defineProperty(this, \"closeOnEsc\", void 0);\n\t\tthis.root = this.attachShadow({ mode: \"open\" });\n\t\tthis.root.appendChild(createTemplate());\n\t\tcodeframeRE.lastIndex = 0;\n\t\tconst hasFrame = err.frame && codeframeRE.test(err.frame);\n\t\tconst message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n\t\tif (err.plugin) this.text(\".plugin\", `[plugin:${err.plugin}] `);\n\t\tthis.text(\".message-body\", message.trim());\n\t\tconst [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n\t\tif (err.loc) this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n\t\telse if (err.id) this.text(\".file\", file);\n\t\tif (hasFrame) this.text(\".frame\", err.frame.trim());\n\t\tthis.text(\".stack\", err.stack, links);\n\t\tthis.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n\t\t\te.stopPropagation();\n\t\t});\n\t\tthis.addEventListener(\"click\", () => {\n\t\t\tthis.close();\n\t\t});\n\t\tthis.closeOnEsc = (e) => {\n\t\t\tif (e.key === \"Escape\" || e.code === \"Escape\") this.close();\n\t\t};\n\t\tdocument.addEventListener(\"keydown\", this.closeOnEsc);\n\t}\n\ttext(selector, text, linkFiles = false) {\n\t\tconst el = this.root.querySelector(selector);\n\t\tif (!linkFiles) el.textContent = text;\n\t\telse {\n\t\t\tlet curIndex = 0;\n\t\t\tlet match;\n\t\t\tfileRE.lastIndex = 0;\n\t\t\twhile (match = fileRE.exec(text)) {\n\t\t\t\tconst { 0: file, index } = match;\n\t\t\t\tconst frag = text.slice(curIndex, index);\n\t\t\t\tel.appendChild(document.createTextNode(frag));\n\t\t\t\tconst link = document.createElement(\"a\");\n\t\t\t\tlink.textContent = file;\n\t\t\t\tlink.className = \"file-link\";\n\t\t\t\tlink.onclick = () => {\n\t\t\t\t\tfetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n\t\t\t\t};\n\t\t\t\tel.appendChild(link);\n\t\t\t\tcurIndex += frag.length + file.length;\n\t\t\t}\n\t\t\tif (curIndex < text.length) el.appendChild(document.createTextNode(text.slice(curIndex)));\n\t\t}\n\t}\n\tclose() {\n\t\tthis.parentNode?.removeChild(this);\n\t\tdocument.removeEventListener(\"keydown\", this.closeOnEsc);\n\t}\n};\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) customElements.define(overlayId, ErrorOverlay);\n\n//#endregion\n//#region src/client/client.ts\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || \"/\";\nconst hmrTimeout = __HMR_TIMEOUT__;\nconst wsToken = __WS_TOKEN__;\nconst transport = normalizeModuleRunnerTransport((() => {\n\tlet wsTransport = createWebSocketModuleRunnerTransport({\n\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${socketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\tpingInterval: hmrTimeout\n\t});\n\treturn {\n\t\tasync connect(handlers) {\n\t\t\ttry {\n\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t} catch (e) {\n\t\t\t\tif (!hmrPort) {\n\t\t\t\t\twsTransport = createWebSocketModuleRunnerTransport({\n\t\t\t\t\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${directSocketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\t\t\t\t\tpingInterval: hmrTimeout\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t\t\t\tconsole.info(\"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\");\n\t\t\t\t\t} catch (e$1) {\n\t\t\t\t\t\tif (e$1 instanceof Error && e$1.message.includes(\"WebSocket closed without opened.\")) {\n\t\t\t\t\t\t\tconst currentScriptHostURL = new URL(import.meta.url);\n\t\t\t\t\t\t\tconst currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n\t\t\t\t\t\t\tconsole.error(`[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.error(`[vite] failed to connect to websocket (${e}). `);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\t\tasync disconnect() {\n\t\t\tawait wsTransport.disconnect();\n\t\t},\n\t\tsend(data) {\n\t\t\twsTransport.send(data);\n\t\t}\n\t};\n})());\nlet willUnload = false;\nif (typeof window !== \"undefined\") window.addEventListener(\"beforeunload\", () => {\n\twillUnload = true;\n});\nfunction cleanUrl(pathname) {\n\tconst url = new URL(pathname, \"http://vite.dev\");\n\turl.searchParams.delete(\"direct\");\n\treturn url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n\tlet timer;\n\treturn () => {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\t\ttimer = setTimeout(() => {\n\t\t\tlocation.reload();\n\t\t}, time);\n\t};\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient({\n\terror: (err) => console.error(\"[vite]\", err),\n\tdebug: (...msg) => console.debug(\"[vite]\", ...msg)\n}, transport, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport }) {\n\tconst [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n\tconst importPromise = import(\n\t/* @vite-ignore */\n\tbase + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`);\n\tif (isWithinCircularImport) importPromise.catch(() => {\n\t\tconsole.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n\t\tpageReload();\n\t});\n\treturn await importPromise;\n});\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n\tswitch (payload.type) {\n\t\tcase \"connected\":\n\t\t\tconsole.debug(`[vite] connected.`);\n\t\t\tbreak;\n\t\tcase \"update\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n\t\t\tif (hasDocument) if (isFirstUpdate && hasErrorOverlay()) {\n\t\t\t\tlocation.reload();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (enableOverlay) clearErrorOverlay();\n\t\t\t\tisFirstUpdate = false;\n\t\t\t}\n\t\t\tawait Promise.all(payload.updates.map(async (update) => {\n\t\t\t\tif (update.type === \"js-update\") return hmrClient.queueUpdate(update);\n\t\t\t\tconst { path, timestamp } = update;\n\t\t\t\tconst searchUrl = cleanUrl(path);\n\t\t\t\tconst el = Array.from(document.querySelectorAll(\"link\")).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n\t\t\t\tif (!el) return;\n\t\t\t\tconst newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tconst newLinkTag = el.cloneNode();\n\t\t\t\t\tnewLinkTag.href = new URL(newPath, el.href).href;\n\t\t\t\t\tconst removeOldEl = () => {\n\t\t\t\t\t\tel.remove();\n\t\t\t\t\t\tconsole.debug(`[vite] css hot updated: ${searchUrl}`);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t};\n\t\t\t\t\tnewLinkTag.addEventListener(\"load\", removeOldEl);\n\t\t\t\t\tnewLinkTag.addEventListener(\"error\", removeOldEl);\n\t\t\t\t\toutdatedLinkTags.add(el);\n\t\t\t\t\tel.after(newLinkTag);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tawait hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n\t\t\tbreak;\n\t\tcase \"custom\": {\n\t\t\tawait hmrClient.notifyListeners(payload.event, payload.data);\n\t\t\tif (payload.event === \"vite:ws:disconnect\") {\n\t\t\t\tif (hasDocument && !willUnload) {\n\t\t\t\t\tconsole.log(`[vite] server connection lost. Polling for restart...`);\n\t\t\t\t\tconst socket = payload.data.webSocket;\n\t\t\t\t\tconst url = new URL(socket.url);\n\t\t\t\t\turl.search = \"\";\n\t\t\t\t\tawait waitForSuccessfulPing(url.href);\n\t\t\t\t\tlocation.reload();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"full-reload\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n\t\t\tif (hasDocument) if (payload.path && payload.path.endsWith(\".html\")) {\n\t\t\t\tconst pagePath = decodeURI(location.pathname);\n\t\t\t\tconst payloadPath = base + payload.path.slice(1);\n\t\t\t\tif (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) pageReload();\n\t\t\t\treturn;\n\t\t\t} else pageReload();\n\t\t\tbreak;\n\t\tcase \"prune\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n\t\t\tawait hmrClient.prunePaths(payload.paths);\n\t\t\tbreak;\n\t\tcase \"error\": {\n\t\t\tawait hmrClient.notifyListeners(\"vite:error\", payload);\n\t\t\tif (hasDocument) {\n\t\t\t\tconst err = payload.err;\n\t\t\t\tif (enableOverlay) createErrorOverlay(err);\n\t\t\t\telse console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"ping\": break;\n\t\tdefault: {\n\t\t\tconst check = payload;\n\t\t\treturn check;\n\t\t}\n\t}\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n\tclearErrorOverlay();\n\tconst { customElements: customElements$1 } = globalThis;\n\tif (customElements$1) {\n\t\tconst ErrorOverlayConstructor = customElements$1.get(overlayId);\n\t\tdocument.body.appendChild(new ErrorOverlayConstructor(err));\n\t}\n}\nfunction clearErrorOverlay() {\n\tdocument.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n\treturn document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n\tasync function ping() {\n\t\tconst socket = new WebSocket(socketUrl, \"vite-ping\");\n\t\treturn new Promise((resolve) => {\n\t\t\tfunction onOpen() {\n\t\t\t\tresolve(true);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction onError() {\n\t\t\t\tresolve(false);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction close() {\n\t\t\t\tsocket.removeEventListener(\"open\", onOpen);\n\t\t\t\tsocket.removeEventListener(\"error\", onError);\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t\tsocket.addEventListener(\"open\", onOpen);\n\t\t\tsocket.addEventListener(\"error\", onError);\n\t\t});\n\t}\n\tif (await ping()) return;\n\tawait wait(ms);\n\twhile (true) if (document.visibilityState === \"visible\") {\n\t\tif (await ping()) break;\n\t\tawait wait(ms);\n\t} else await waitForWindowShow();\n}\nfunction wait(ms) {\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n\treturn new Promise((resolve) => {\n\t\tconst onChange = async () => {\n\t\t\tif (document.visibilityState === \"visible\") {\n\t\t\t\tresolve();\n\t\t\t\tdocument.removeEventListener(\"visibilitychange\", onChange);\n\t\t\t}\n\t\t};\n\t\tdocument.addEventListener(\"visibilitychange\", onChange);\n\t});\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n\tsheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n});\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n\tlet style = sheetsMap.get(id);\n\tif (!style) {\n\t\tstyle = document.createElement(\"style\");\n\t\tstyle.setAttribute(\"type\", \"text/css\");\n\t\tstyle.setAttribute(\"data-vite-dev-id\", id);\n\t\tstyle.textContent = content;\n\t\tif (cspNonce) style.setAttribute(\"nonce\", cspNonce);\n\t\tif (!lastInsertedStyle) {\n\t\t\tdocument.head.appendChild(style);\n\t\t\tsetTimeout(() => {\n\t\t\t\tlastInsertedStyle = void 0;\n\t\t\t}, 0);\n\t\t} else lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n\t\tlastInsertedStyle = style;\n\t} else style.textContent = content;\n\tsheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n\tconst style = sheetsMap.get(id);\n\tif (style) {\n\t\tdocument.head.removeChild(style);\n\t\tsheetsMap.delete(id);\n\t}\n}\nfunction createHotContext(ownerPath) {\n\treturn new HMRContext(hmrClient, ownerPath);\n}\n/**\n* urls here are dynamic import() urls that couldn't be statically analyzed\n*/\nfunction injectQuery(url, queryToInject) {\n\tif (url[0] !== \".\" && url[0] !== \"/\") return url;\n\tconst pathname = url.replace(/[?#].*$/, \"\");\n\tconst { search, hash } = new URL(url, \"http://vite.dev\");\n\treturn `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\n//#endregion\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite-plugin-svgr",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:css-post",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:client-inject",
      "result": "import \"@vite/env\";\n\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/typeof.js\nfunction _typeof(o) {\n\t\"@babel/helpers - typeof\";\n\treturn _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\treturn typeof o$1;\n\t} : function(o$1) {\n\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t}, _typeof(o);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPrimitive.js\nfunction toPrimitive(t, r) {\n\tif (\"object\" != _typeof(t) || !t) return t;\n\tvar e = t[Symbol.toPrimitive];\n\tif (void 0 !== e) {\n\t\tvar i = e.call(t, r || \"default\");\n\t\tif (\"object\" != _typeof(i)) return i;\n\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t}\n\treturn (\"string\" === r ? String : Number)(t);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPropertyKey.js\nfunction toPropertyKey(t) {\n\tvar i = toPrimitive(t, \"string\");\n\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/defineProperty.js\nfunction _defineProperty(e, r, t) {\n\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\tvalue: t,\n\t\tenumerable: !0,\n\t\tconfigurable: !0,\n\t\twritable: !0\n\t}) : e[r] = t, e;\n}\n\n//#endregion\n//#region src/shared/hmr.ts\nvar HMRContext = class {\n\tconstructor(hmrClient$1, ownerPath) {\n\t\tthis.hmrClient = hmrClient$1;\n\t\tthis.ownerPath = ownerPath;\n\t\t_defineProperty(this, \"newListeners\", void 0);\n\t\tif (!hmrClient$1.dataMap.has(ownerPath)) hmrClient$1.dataMap.set(ownerPath, {});\n\t\tconst mod = hmrClient$1.hotModulesMap.get(ownerPath);\n\t\tif (mod) mod.callbacks = [];\n\t\tconst staleListeners = hmrClient$1.ctxToListenersMap.get(ownerPath);\n\t\tif (staleListeners) for (const [event, staleFns] of staleListeners) {\n\t\t\tconst listeners = hmrClient$1.customListenersMap.get(event);\n\t\t\tif (listeners) hmrClient$1.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n\t\t}\n\t\tthis.newListeners = /* @__PURE__ */ new Map();\n\t\thmrClient$1.ctxToListenersMap.set(ownerPath, this.newListeners);\n\t}\n\tget data() {\n\t\treturn this.hmrClient.dataMap.get(this.ownerPath);\n\t}\n\taccept(deps, callback) {\n\t\tif (typeof deps === \"function\" || !deps) this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n\t\telse if (typeof deps === \"string\") this.acceptDeps([deps], ([mod]) => callback?.(mod));\n\t\telse if (Array.isArray(deps)) this.acceptDeps(deps, callback);\n\t\telse throw new Error(`invalid hot.accept() usage.`);\n\t}\n\tacceptExports(_, callback) {\n\t\tthis.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n\t}\n\tdispose(cb) {\n\t\tthis.hmrClient.disposeMap.set(this.ownerPath, cb);\n\t}\n\tprune(cb) {\n\t\tthis.hmrClient.pruneMap.set(this.ownerPath, cb);\n\t}\n\tdecline() {}\n\tinvalidate(message) {\n\t\tconst firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n\t\tthis.hmrClient.notifyListeners(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.send(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.hmrClient.logger.debug(`invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`);\n\t}\n\ton(event, cb) {\n\t\tconst addToMap = (map) => {\n\t\t\tconst existing = map.get(event) || [];\n\t\t\texisting.push(cb);\n\t\t\tmap.set(event, existing);\n\t\t};\n\t\taddToMap(this.hmrClient.customListenersMap);\n\t\taddToMap(this.newListeners);\n\t}\n\toff(event, cb) {\n\t\tconst removeFromMap = (map) => {\n\t\t\tconst existing = map.get(event);\n\t\t\tif (existing === void 0) return;\n\t\t\tconst pruned = existing.filter((l) => l !== cb);\n\t\t\tif (pruned.length === 0) {\n\t\t\t\tmap.delete(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(event, pruned);\n\t\t};\n\t\tremoveFromMap(this.hmrClient.customListenersMap);\n\t\tremoveFromMap(this.newListeners);\n\t}\n\tsend(event, data) {\n\t\tthis.hmrClient.send({\n\t\t\ttype: \"custom\",\n\t\t\tevent,\n\t\t\tdata\n\t\t});\n\t}\n\tacceptDeps(deps, callback = () => {}) {\n\t\tconst mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n\t\t\tid: this.ownerPath,\n\t\t\tcallbacks: []\n\t\t};\n\t\tmod.callbacks.push({\n\t\t\tdeps,\n\t\t\tfn: callback\n\t\t});\n\t\tthis.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n\t}\n};\nvar HMRClient = class {\n\tconstructor(logger, transport$1, importUpdatedModule) {\n\t\tthis.logger = logger;\n\t\tthis.transport = transport$1;\n\t\tthis.importUpdatedModule = importUpdatedModule;\n\t\t_defineProperty(this, \"hotModulesMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"disposeMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"pruneMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"dataMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"customListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"ctxToListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"currentFirstInvalidatedBy\", void 0);\n\t\t_defineProperty(this, \"updateQueue\", []);\n\t\t_defineProperty(this, \"pendingUpdateQueue\", false);\n\t}\n\tasync notifyListeners(event, data) {\n\t\tconst cbs = this.customListenersMap.get(event);\n\t\tif (cbs) await Promise.allSettled(cbs.map((cb) => cb(data)));\n\t}\n\tsend(payload) {\n\t\tthis.transport.send(payload).catch((err) => {\n\t\t\tthis.logger.error(err);\n\t\t});\n\t}\n\tclear() {\n\t\tthis.hotModulesMap.clear();\n\t\tthis.disposeMap.clear();\n\t\tthis.pruneMap.clear();\n\t\tthis.dataMap.clear();\n\t\tthis.customListenersMap.clear();\n\t\tthis.ctxToListenersMap.clear();\n\t}\n\tasync prunePaths(paths) {\n\t\tawait Promise.all(paths.map((path) => {\n\t\t\tconst disposer = this.disposeMap.get(path);\n\t\t\tif (disposer) return disposer(this.dataMap.get(path));\n\t\t}));\n\t\tpaths.forEach((path) => {\n\t\t\tconst fn = this.pruneMap.get(path);\n\t\t\tif (fn) fn(this.dataMap.get(path));\n\t\t});\n\t}\n\twarnFailedUpdate(err, path) {\n\t\tif (!(err instanceof Error) || !err.message.includes(\"fetch\")) this.logger.error(err);\n\t\tthis.logger.error(`Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`);\n\t}\n\t/**\n\t* buffer multiple hot updates triggered by the same src change\n\t* so that they are invoked in the same order they were sent.\n\t* (otherwise the order may be inconsistent because of the http request round trip)\n\t*/\n\tasync queueUpdate(payload) {\n\t\tthis.updateQueue.push(this.fetchUpdate(payload));\n\t\tif (!this.pendingUpdateQueue) {\n\t\t\tthis.pendingUpdateQueue = true;\n\t\t\tawait Promise.resolve();\n\t\t\tthis.pendingUpdateQueue = false;\n\t\t\tconst loading = [...this.updateQueue];\n\t\t\tthis.updateQueue = [];\n\t\t\t(await Promise.all(loading)).forEach((fn) => fn && fn());\n\t\t}\n\t}\n\tasync fetchUpdate(update) {\n\t\tconst { path, acceptedPath, firstInvalidatedBy } = update;\n\t\tconst mod = this.hotModulesMap.get(path);\n\t\tif (!mod) return;\n\t\tlet fetchedModule;\n\t\tconst isSelfUpdate = path === acceptedPath;\n\t\tconst qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n\t\tif (isSelfUpdate || qualifiedCallbacks.length > 0) {\n\t\t\tconst disposer = this.disposeMap.get(acceptedPath);\n\t\t\tif (disposer) await disposer(this.dataMap.get(acceptedPath));\n\t\t\ttry {\n\t\t\t\tfetchedModule = await this.importUpdatedModule(update);\n\t\t\t} catch (e) {\n\t\t\t\tthis.warnFailedUpdate(e, acceptedPath);\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\ttry {\n\t\t\t\tthis.currentFirstInvalidatedBy = firstInvalidatedBy;\n\t\t\t\tfor (const { deps, fn } of qualifiedCallbacks) fn(deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0));\n\t\t\t\tconst loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n\t\t\t\tthis.logger.debug(`hot updated: ${loggedPath}`);\n\t\t\t} finally {\n\t\t\t\tthis.currentFirstInvalidatedBy = void 0;\n\t\t\t}\n\t\t};\n\t}\n};\n\n//#endregion\n//#region ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/non-secure/index.js\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet nanoid = (size = 21) => {\n\tlet id = \"\";\n\tlet i = size | 0;\n\twhile (i--) id += urlAlphabet[Math.random() * 64 | 0];\n\treturn id;\n};\n\n//#endregion\n//#region src/shared/constants.ts\nlet SOURCEMAPPING_URL = \"sourceMa\";\nSOURCEMAPPING_URL += \"ppingURL\";\n\n//#endregion\n//#region src/shared/utils.ts\nconst isWindows = typeof process !== \"undefined\" && process.platform === \"win32\";\nconst AsyncFunction = async function() {}.constructor;\nfunction promiseWithResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/shared/moduleRunnerTransport.ts\nfunction reviveInvokeError(e) {\n\tconst error = new Error(e.message || \"Unknown invoke error\");\n\tObject.assign(error, e, { runnerError: /* @__PURE__ */ new Error(\"RunnerError\") });\n\treturn error;\n}\nconst createInvokeableTransport = (transport$1) => {\n\tif (transport$1.invoke) return {\n\t\t...transport$1,\n\t\tasync invoke(name, data) {\n\t\t\tconst result = await transport$1.invoke({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tid: \"send\",\n\t\t\t\t\tname,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (\"error\" in result) throw reviveInvokeError(result.error);\n\t\t\treturn result.result;\n\t\t}\n\t};\n\tif (!transport$1.send || !transport$1.connect) throw new Error(\"transport must implement send and connect when invoke is not implemented\");\n\tconst rpcPromises = /* @__PURE__ */ new Map();\n\treturn {\n\t\t...transport$1,\n\t\tconnect({ onMessage, onDisconnection }) {\n\t\t\treturn transport$1.connect({\n\t\t\t\tonMessage(payload) {\n\t\t\t\t\tif (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n\t\t\t\t\t\tconst data = payload.data;\n\t\t\t\t\t\tif (data.id.startsWith(\"response:\")) {\n\t\t\t\t\t\t\tconst invokeId = data.id.slice(9);\n\t\t\t\t\t\t\tconst promise = rpcPromises.get(invokeId);\n\t\t\t\t\t\t\tif (!promise) return;\n\t\t\t\t\t\t\tif (promise.timeoutId) clearTimeout(promise.timeoutId);\n\t\t\t\t\t\t\trpcPromises.delete(invokeId);\n\t\t\t\t\t\t\tconst { error, result } = data.data;\n\t\t\t\t\t\t\tif (error) promise.reject(error);\n\t\t\t\t\t\t\telse promise.resolve(result);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tonMessage(payload);\n\t\t\t\t},\n\t\t\t\tonDisconnection\n\t\t\t});\n\t\t},\n\t\tdisconnect() {\n\t\t\trpcPromises.forEach((promise) => {\n\t\t\t\tpromise.reject(/* @__PURE__ */ new Error(`transport was disconnected, cannot call ${JSON.stringify(promise.name)}`));\n\t\t\t});\n\t\t\trpcPromises.clear();\n\t\t\treturn transport$1.disconnect?.();\n\t\t},\n\t\tsend(data) {\n\t\t\treturn transport$1.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tconst promiseId = nanoid();\n\t\t\tconst wrappedData = {\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tname,\n\t\t\t\t\tid: `send:${promiseId}`,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst sendPromise = transport$1.send(wrappedData);\n\t\t\tconst { promise, resolve, reject } = promiseWithResolvers();\n\t\t\tconst timeout = transport$1.timeout ?? 6e4;\n\t\t\tlet timeoutId;\n\t\t\tif (timeout > 0) {\n\t\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\t\treject(/* @__PURE__ */ new Error(`transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`));\n\t\t\t\t}, timeout);\n\t\t\t\ttimeoutId?.unref?.();\n\t\t\t}\n\t\t\trpcPromises.set(promiseId, {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\tname,\n\t\t\t\ttimeoutId\n\t\t\t});\n\t\t\tif (sendPromise) sendPromise.catch((err) => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\ttry {\n\t\t\t\treturn await promise;\n\t\t\t} catch (err) {\n\t\t\t\tthrow reviveInvokeError(err);\n\t\t\t}\n\t\t}\n\t};\n};\nconst normalizeModuleRunnerTransport = (transport$1) => {\n\tconst invokeableTransport = createInvokeableTransport(transport$1);\n\tlet isConnected = !invokeableTransport.connect;\n\tlet connectingPromise;\n\treturn {\n\t\t...transport$1,\n\t\t...invokeableTransport.connect ? { async connect(onMessage) {\n\t\t\tif (isConnected) return;\n\t\t\tif (connectingPromise) {\n\t\t\t\tawait connectingPromise;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst maybePromise = invokeableTransport.connect({\n\t\t\t\tonMessage: onMessage ?? (() => {}),\n\t\t\t\tonDisconnection() {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (maybePromise) {\n\t\t\t\tconnectingPromise = maybePromise;\n\t\t\t\tawait connectingPromise;\n\t\t\t\tconnectingPromise = void 0;\n\t\t\t}\n\t\t\tisConnected = true;\n\t\t} } : {},\n\t\t...invokeableTransport.disconnect ? { async disconnect() {\n\t\t\tif (!isConnected) return;\n\t\t\tif (connectingPromise) await connectingPromise;\n\t\t\tisConnected = false;\n\t\t\tawait invokeableTransport.disconnect();\n\t\t} } : {},\n\t\tasync send(data) {\n\t\t\tif (!invokeableTransport.send) return;\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"send was called before connect\");\n\t\t\tawait invokeableTransport.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"invoke was called before connect\");\n\t\t\treturn invokeableTransport.invoke(name, data);\n\t\t}\n\t};\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n\tconst pingInterval = options.pingInterval ?? 3e4;\n\tlet ws;\n\tlet pingIntervalId;\n\treturn {\n\t\tasync connect({ onMessage, onDisconnection }) {\n\t\t\tconst socket = options.createConnection();\n\t\t\tsocket.addEventListener(\"message\", async ({ data }) => {\n\t\t\t\tonMessage(JSON.parse(data));\n\t\t\t});\n\t\t\tlet isOpened = socket.readyState === socket.OPEN;\n\t\t\tif (!isOpened) await new Promise((resolve, reject) => {\n\t\t\t\tsocket.addEventListener(\"open\", () => {\n\t\t\t\t\tisOpened = true;\n\t\t\t\t\tresolve();\n\t\t\t\t}, { once: true });\n\t\t\t\tsocket.addEventListener(\"close\", async () => {\n\t\t\t\t\tif (!isOpened) {\n\t\t\t\t\t\treject(/* @__PURE__ */ new Error(\"WebSocket closed without opened.\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonMessage({\n\t\t\t\t\t\ttype: \"custom\",\n\t\t\t\t\t\tevent: \"vite:ws:disconnect\",\n\t\t\t\t\t\tdata: { webSocket: socket }\n\t\t\t\t\t});\n\t\t\t\t\tonDisconnection();\n\t\t\t\t});\n\t\t\t});\n\t\t\tonMessage({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:ws:connect\",\n\t\t\t\tdata: { webSocket: socket }\n\t\t\t});\n\t\t\tws = socket;\n\t\t\tpingIntervalId = setInterval(() => {\n\t\t\t\tif (socket.readyState === socket.OPEN) socket.send(JSON.stringify({ type: \"ping\" }));\n\t\t\t}, pingInterval);\n\t\t},\n\t\tdisconnect() {\n\t\t\tclearInterval(pingIntervalId);\n\t\t\tws?.close();\n\t\t},\n\t\tsend(data) {\n\t\t\tws.send(JSON.stringify(data));\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/shared/hmrHandler.ts\nfunction createHMRHandler(handler) {\n\tconst queue = new Queue();\n\treturn (payload) => queue.enqueue(() => handler(payload));\n}\nvar Queue = class {\n\tconstructor() {\n\t\t_defineProperty(this, \"queue\", []);\n\t\t_defineProperty(this, \"pending\", false);\n\t}\n\tenqueue(promise) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.queue.push({\n\t\t\t\tpromise,\n\t\t\t\tresolve,\n\t\t\t\treject\n\t\t\t});\n\t\t\tthis.dequeue();\n\t\t});\n\t}\n\tdequeue() {\n\t\tif (this.pending) return false;\n\t\tconst item = this.queue.shift();\n\t\tif (!item) return false;\n\t\tthis.pending = true;\n\t\titem.promise().then(item.resolve).catch(item.reject).finally(() => {\n\t\t\tthis.pending = false;\n\t\t\tthis.dequeue();\n\t\t});\n\t\treturn true;\n\t}\n};\n\n//#endregion\n//#region src/client/overlay.ts\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || \"/\";\nfunction h(e, attrs = {}, ...children) {\n\tconst elem = document.createElement(e);\n\tfor (const [k, v] of Object.entries(attrs)) elem.setAttribute(k, v);\n\telem.append(...children);\n\treturn elem;\n}\nconst templateStyle = `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\nconst createTemplate = () => h(\"div\", {\n\tclass: \"backdrop\",\n\tpart: \"backdrop\"\n}, h(\"div\", {\n\tclass: \"window\",\n\tpart: \"window\"\n}, h(\"pre\", {\n\tclass: \"message\",\n\tpart: \"message\"\n}, h(\"span\", {\n\tclass: \"plugin\",\n\tpart: \"plugin\"\n}), h(\"span\", {\n\tclass: \"message-body\",\n\tpart: \"message-body\"\n})), h(\"pre\", {\n\tclass: \"file\",\n\tpart: \"file\"\n}), h(\"pre\", {\n\tclass: \"frame\",\n\tpart: \"frame\"\n}), h(\"pre\", {\n\tclass: \"stack\",\n\tpart: \"stack\"\n}), h(\"div\", {\n\tclass: \"tip\",\n\tpart: \"tip\"\n}, \"Click outside, press \", h(\"kbd\", {}, \"Esc\"), \" key, or fix the code to dismiss.\", h(\"br\"), \"You can also disable this overlay by setting \", h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"), \" to \", h(\"code\", { part: \"config-option-value\" }, \"false\"), \" in \", h(\"code\", { part: \"config-file-name\" }, hmrConfigName), \".\")), h(\"style\", {}, templateStyle));\nconst fileRE = /(?:file:\\/\\/)?(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {} } = globalThis;\nvar ErrorOverlay = class extends HTMLElement {\n\tconstructor(err, links = true) {\n\t\tsuper();\n\t\t_defineProperty(this, \"root\", void 0);\n\t\t_defineProperty(this, \"closeOnEsc\", void 0);\n\t\tthis.root = this.attachShadow({ mode: \"open\" });\n\t\tthis.root.appendChild(createTemplate());\n\t\tcodeframeRE.lastIndex = 0;\n\t\tconst hasFrame = err.frame && codeframeRE.test(err.frame);\n\t\tconst message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n\t\tif (err.plugin) this.text(\".plugin\", `[plugin:${err.plugin}] `);\n\t\tthis.text(\".message-body\", message.trim());\n\t\tconst [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n\t\tif (err.loc) this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n\t\telse if (err.id) this.text(\".file\", file);\n\t\tif (hasFrame) this.text(\".frame\", err.frame.trim());\n\t\tthis.text(\".stack\", err.stack, links);\n\t\tthis.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n\t\t\te.stopPropagation();\n\t\t});\n\t\tthis.addEventListener(\"click\", () => {\n\t\t\tthis.close();\n\t\t});\n\t\tthis.closeOnEsc = (e) => {\n\t\t\tif (e.key === \"Escape\" || e.code === \"Escape\") this.close();\n\t\t};\n\t\tdocument.addEventListener(\"keydown\", this.closeOnEsc);\n\t}\n\ttext(selector, text, linkFiles = false) {\n\t\tconst el = this.root.querySelector(selector);\n\t\tif (!linkFiles) el.textContent = text;\n\t\telse {\n\t\t\tlet curIndex = 0;\n\t\t\tlet match;\n\t\t\tfileRE.lastIndex = 0;\n\t\t\twhile (match = fileRE.exec(text)) {\n\t\t\t\tconst { 0: file, index } = match;\n\t\t\t\tconst frag = text.slice(curIndex, index);\n\t\t\t\tel.appendChild(document.createTextNode(frag));\n\t\t\t\tconst link = document.createElement(\"a\");\n\t\t\t\tlink.textContent = file;\n\t\t\t\tlink.className = \"file-link\";\n\t\t\t\tlink.onclick = () => {\n\t\t\t\t\tfetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n\t\t\t\t};\n\t\t\t\tel.appendChild(link);\n\t\t\t\tcurIndex += frag.length + file.length;\n\t\t\t}\n\t\t\tif (curIndex < text.length) el.appendChild(document.createTextNode(text.slice(curIndex)));\n\t\t}\n\t}\n\tclose() {\n\t\tthis.parentNode?.removeChild(this);\n\t\tdocument.removeEventListener(\"keydown\", this.closeOnEsc);\n\t}\n};\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) customElements.define(overlayId, ErrorOverlay);\n\n//#endregion\n//#region src/client/client.ts\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = \"localhost:5173/\";\nconst socketProtocol = null || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:5173/\";\nconst base = \"/\" || \"/\";\nconst hmrTimeout = 30000;\nconst wsToken = \"-S4TfoOQXiZY\";\nconst transport = normalizeModuleRunnerTransport((() => {\n\tlet wsTransport = createWebSocketModuleRunnerTransport({\n\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${socketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\tpingInterval: hmrTimeout\n\t});\n\treturn {\n\t\tasync connect(handlers) {\n\t\t\ttry {\n\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t} catch (e) {\n\t\t\t\tif (!hmrPort) {\n\t\t\t\t\twsTransport = createWebSocketModuleRunnerTransport({\n\t\t\t\t\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${directSocketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\t\t\t\t\tpingInterval: hmrTimeout\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t\t\t\tconsole.info(\"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\");\n\t\t\t\t\t} catch (e$1) {\n\t\t\t\t\t\tif (e$1 instanceof Error && e$1.message.includes(\"WebSocket closed without opened.\")) {\n\t\t\t\t\t\t\tconst currentScriptHostURL = new URL(import.meta.url);\n\t\t\t\t\t\t\tconst currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n\t\t\t\t\t\t\tconsole.error(`[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.error(`[vite] failed to connect to websocket (${e}). `);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\t\tasync disconnect() {\n\t\t\tawait wsTransport.disconnect();\n\t\t},\n\t\tsend(data) {\n\t\t\twsTransport.send(data);\n\t\t}\n\t};\n})());\nlet willUnload = false;\nif (typeof window !== \"undefined\") window.addEventListener(\"beforeunload\", () => {\n\twillUnload = true;\n});\nfunction cleanUrl(pathname) {\n\tconst url = new URL(pathname, \"http://vite.dev\");\n\turl.searchParams.delete(\"direct\");\n\treturn url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n\tlet timer;\n\treturn () => {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\t\ttimer = setTimeout(() => {\n\t\t\tlocation.reload();\n\t\t}, time);\n\t};\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient({\n\terror: (err) => console.error(\"[vite]\", err),\n\tdebug: (...msg) => console.debug(\"[vite]\", ...msg)\n}, transport, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport }) {\n\tconst [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n\tconst importPromise = import(\n\t/* @vite-ignore */\n\tbase + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`);\n\tif (isWithinCircularImport) importPromise.catch(() => {\n\t\tconsole.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n\t\tpageReload();\n\t});\n\treturn await importPromise;\n});\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n\tswitch (payload.type) {\n\t\tcase \"connected\":\n\t\t\tconsole.debug(`[vite] connected.`);\n\t\t\tbreak;\n\t\tcase \"update\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n\t\t\tif (hasDocument) if (isFirstUpdate && hasErrorOverlay()) {\n\t\t\t\tlocation.reload();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (enableOverlay) clearErrorOverlay();\n\t\t\t\tisFirstUpdate = false;\n\t\t\t}\n\t\t\tawait Promise.all(payload.updates.map(async (update) => {\n\t\t\t\tif (update.type === \"js-update\") return hmrClient.queueUpdate(update);\n\t\t\t\tconst { path, timestamp } = update;\n\t\t\t\tconst searchUrl = cleanUrl(path);\n\t\t\t\tconst el = Array.from(document.querySelectorAll(\"link\")).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n\t\t\t\tif (!el) return;\n\t\t\t\tconst newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tconst newLinkTag = el.cloneNode();\n\t\t\t\t\tnewLinkTag.href = new URL(newPath, el.href).href;\n\t\t\t\t\tconst removeOldEl = () => {\n\t\t\t\t\t\tel.remove();\n\t\t\t\t\t\tconsole.debug(`[vite] css hot updated: ${searchUrl}`);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t};\n\t\t\t\t\tnewLinkTag.addEventListener(\"load\", removeOldEl);\n\t\t\t\t\tnewLinkTag.addEventListener(\"error\", removeOldEl);\n\t\t\t\t\toutdatedLinkTags.add(el);\n\t\t\t\t\tel.after(newLinkTag);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tawait hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n\t\t\tbreak;\n\t\tcase \"custom\": {\n\t\t\tawait hmrClient.notifyListeners(payload.event, payload.data);\n\t\t\tif (payload.event === \"vite:ws:disconnect\") {\n\t\t\t\tif (hasDocument && !willUnload) {\n\t\t\t\t\tconsole.log(`[vite] server connection lost. Polling for restart...`);\n\t\t\t\t\tconst socket = payload.data.webSocket;\n\t\t\t\t\tconst url = new URL(socket.url);\n\t\t\t\t\turl.search = \"\";\n\t\t\t\t\tawait waitForSuccessfulPing(url.href);\n\t\t\t\t\tlocation.reload();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"full-reload\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n\t\t\tif (hasDocument) if (payload.path && payload.path.endsWith(\".html\")) {\n\t\t\t\tconst pagePath = decodeURI(location.pathname);\n\t\t\t\tconst payloadPath = base + payload.path.slice(1);\n\t\t\t\tif (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) pageReload();\n\t\t\t\treturn;\n\t\t\t} else pageReload();\n\t\t\tbreak;\n\t\tcase \"prune\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n\t\t\tawait hmrClient.prunePaths(payload.paths);\n\t\t\tbreak;\n\t\tcase \"error\": {\n\t\t\tawait hmrClient.notifyListeners(\"vite:error\", payload);\n\t\t\tif (hasDocument) {\n\t\t\t\tconst err = payload.err;\n\t\t\t\tif (enableOverlay) createErrorOverlay(err);\n\t\t\t\telse console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"ping\": break;\n\t\tdefault: {\n\t\t\tconst check = payload;\n\t\t\treturn check;\n\t\t}\n\t}\n}\nconst enableOverlay = true;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n\tclearErrorOverlay();\n\tconst { customElements: customElements$1 } = globalThis;\n\tif (customElements$1) {\n\t\tconst ErrorOverlayConstructor = customElements$1.get(overlayId);\n\t\tdocument.body.appendChild(new ErrorOverlayConstructor(err));\n\t}\n}\nfunction clearErrorOverlay() {\n\tdocument.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n\treturn document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n\tasync function ping() {\n\t\tconst socket = new WebSocket(socketUrl, \"vite-ping\");\n\t\treturn new Promise((resolve) => {\n\t\t\tfunction onOpen() {\n\t\t\t\tresolve(true);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction onError() {\n\t\t\t\tresolve(false);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction close() {\n\t\t\t\tsocket.removeEventListener(\"open\", onOpen);\n\t\t\t\tsocket.removeEventListener(\"error\", onError);\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t\tsocket.addEventListener(\"open\", onOpen);\n\t\t\tsocket.addEventListener(\"error\", onError);\n\t\t});\n\t}\n\tif (await ping()) return;\n\tawait wait(ms);\n\twhile (true) if (document.visibilityState === \"visible\") {\n\t\tif (await ping()) break;\n\t\tawait wait(ms);\n\t} else await waitForWindowShow();\n}\nfunction wait(ms) {\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n\treturn new Promise((resolve) => {\n\t\tconst onChange = async () => {\n\t\t\tif (document.visibilityState === \"visible\") {\n\t\t\t\tresolve();\n\t\t\t\tdocument.removeEventListener(\"visibilitychange\", onChange);\n\t\t\t}\n\t\t};\n\t\tdocument.addEventListener(\"visibilitychange\", onChange);\n\t});\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n\tsheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n});\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n\tlet style = sheetsMap.get(id);\n\tif (!style) {\n\t\tstyle = document.createElement(\"style\");\n\t\tstyle.setAttribute(\"type\", \"text/css\");\n\t\tstyle.setAttribute(\"data-vite-dev-id\", id);\n\t\tstyle.textContent = content;\n\t\tif (cspNonce) style.setAttribute(\"nonce\", cspNonce);\n\t\tif (!lastInsertedStyle) {\n\t\t\tdocument.head.appendChild(style);\n\t\t\tsetTimeout(() => {\n\t\t\t\tlastInsertedStyle = void 0;\n\t\t\t}, 0);\n\t\t} else lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n\t\tlastInsertedStyle = style;\n\t} else style.textContent = content;\n\tsheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n\tconst style = sheetsMap.get(id);\n\tif (style) {\n\t\tdocument.head.removeChild(style);\n\t\tsheetsMap.delete(id);\n\t}\n}\nfunction createHotContext(ownerPath) {\n\treturn new HMRContext(hmrClient, ownerPath);\n}\n/**\n* urls here are dynamic import() urls that couldn't be statically analyzed\n*/\nfunction injectQuery(url, queryToInject) {\n\tif (url[0] !== \".\" && url[0] !== \"/\") return url;\n\tconst pathname = url.replace(/[?#].*$/, \"\");\n\tconst { search, hash } = new URL(url, \"http://vite.dev\");\n\treturn `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\n//#endregion\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-analysis",
      "start": 1751213799881,
      "end": 1751213799881,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import \"/node_modules/.pnpm/vite@7.0.0/node_modules/vite/dist/client/env.mjs\";\n\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/typeof.js\nfunction _typeof(o) {\n\t\"@babel/helpers - typeof\";\n\treturn _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\treturn typeof o$1;\n\t} : function(o$1) {\n\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t}, _typeof(o);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPrimitive.js\nfunction toPrimitive(t, r) {\n\tif (\"object\" != _typeof(t) || !t) return t;\n\tvar e = t[Symbol.toPrimitive];\n\tif (void 0 !== e) {\n\t\tvar i = e.call(t, r || \"default\");\n\t\tif (\"object\" != _typeof(i)) return i;\n\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t}\n\treturn (\"string\" === r ? String : Number)(t);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/toPropertyKey.js\nfunction toPropertyKey(t) {\n\tvar i = toPrimitive(t, \"string\");\n\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.73.2/node_modules/@oxc-project/runtime/src/helpers/esm/defineProperty.js\nfunction _defineProperty(e, r, t) {\n\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\tvalue: t,\n\t\tenumerable: !0,\n\t\tconfigurable: !0,\n\t\twritable: !0\n\t}) : e[r] = t, e;\n}\n\n//#endregion\n//#region src/shared/hmr.ts\nvar HMRContext = class {\n\tconstructor(hmrClient$1, ownerPath) {\n\t\tthis.hmrClient = hmrClient$1;\n\t\tthis.ownerPath = ownerPath;\n\t\t_defineProperty(this, \"newListeners\", void 0);\n\t\tif (!hmrClient$1.dataMap.has(ownerPath)) hmrClient$1.dataMap.set(ownerPath, {});\n\t\tconst mod = hmrClient$1.hotModulesMap.get(ownerPath);\n\t\tif (mod) mod.callbacks = [];\n\t\tconst staleListeners = hmrClient$1.ctxToListenersMap.get(ownerPath);\n\t\tif (staleListeners) for (const [event, staleFns] of staleListeners) {\n\t\t\tconst listeners = hmrClient$1.customListenersMap.get(event);\n\t\t\tif (listeners) hmrClient$1.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n\t\t}\n\t\tthis.newListeners = /* @__PURE__ */ new Map();\n\t\thmrClient$1.ctxToListenersMap.set(ownerPath, this.newListeners);\n\t}\n\tget data() {\n\t\treturn this.hmrClient.dataMap.get(this.ownerPath);\n\t}\n\taccept(deps, callback) {\n\t\tif (typeof deps === \"function\" || !deps) this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n\t\telse if (typeof deps === \"string\") this.acceptDeps([deps], ([mod]) => callback?.(mod));\n\t\telse if (Array.isArray(deps)) this.acceptDeps(deps, callback);\n\t\telse throw new Error(`invalid hot.accept() usage.`);\n\t}\n\tacceptExports(_, callback) {\n\t\tthis.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n\t}\n\tdispose(cb) {\n\t\tthis.hmrClient.disposeMap.set(this.ownerPath, cb);\n\t}\n\tprune(cb) {\n\t\tthis.hmrClient.pruneMap.set(this.ownerPath, cb);\n\t}\n\tdecline() {}\n\tinvalidate(message) {\n\t\tconst firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n\t\tthis.hmrClient.notifyListeners(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.send(\"vite:invalidate\", {\n\t\t\tpath: this.ownerPath,\n\t\t\tmessage,\n\t\t\tfirstInvalidatedBy\n\t\t});\n\t\tthis.hmrClient.logger.debug(`invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`);\n\t}\n\ton(event, cb) {\n\t\tconst addToMap = (map) => {\n\t\t\tconst existing = map.get(event) || [];\n\t\t\texisting.push(cb);\n\t\t\tmap.set(event, existing);\n\t\t};\n\t\taddToMap(this.hmrClient.customListenersMap);\n\t\taddToMap(this.newListeners);\n\t}\n\toff(event, cb) {\n\t\tconst removeFromMap = (map) => {\n\t\t\tconst existing = map.get(event);\n\t\t\tif (existing === void 0) return;\n\t\t\tconst pruned = existing.filter((l) => l !== cb);\n\t\t\tif (pruned.length === 0) {\n\t\t\t\tmap.delete(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(event, pruned);\n\t\t};\n\t\tremoveFromMap(this.hmrClient.customListenersMap);\n\t\tremoveFromMap(this.newListeners);\n\t}\n\tsend(event, data) {\n\t\tthis.hmrClient.send({\n\t\t\ttype: \"custom\",\n\t\t\tevent,\n\t\t\tdata\n\t\t});\n\t}\n\tacceptDeps(deps, callback = () => {}) {\n\t\tconst mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n\t\t\tid: this.ownerPath,\n\t\t\tcallbacks: []\n\t\t};\n\t\tmod.callbacks.push({\n\t\t\tdeps,\n\t\t\tfn: callback\n\t\t});\n\t\tthis.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n\t}\n};\nvar HMRClient = class {\n\tconstructor(logger, transport$1, importUpdatedModule) {\n\t\tthis.logger = logger;\n\t\tthis.transport = transport$1;\n\t\tthis.importUpdatedModule = importUpdatedModule;\n\t\t_defineProperty(this, \"hotModulesMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"disposeMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"pruneMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"dataMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"customListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"ctxToListenersMap\", /* @__PURE__ */ new Map());\n\t\t_defineProperty(this, \"currentFirstInvalidatedBy\", void 0);\n\t\t_defineProperty(this, \"updateQueue\", []);\n\t\t_defineProperty(this, \"pendingUpdateQueue\", false);\n\t}\n\tasync notifyListeners(event, data) {\n\t\tconst cbs = this.customListenersMap.get(event);\n\t\tif (cbs) await Promise.allSettled(cbs.map((cb) => cb(data)));\n\t}\n\tsend(payload) {\n\t\tthis.transport.send(payload).catch((err) => {\n\t\t\tthis.logger.error(err);\n\t\t});\n\t}\n\tclear() {\n\t\tthis.hotModulesMap.clear();\n\t\tthis.disposeMap.clear();\n\t\tthis.pruneMap.clear();\n\t\tthis.dataMap.clear();\n\t\tthis.customListenersMap.clear();\n\t\tthis.ctxToListenersMap.clear();\n\t}\n\tasync prunePaths(paths) {\n\t\tawait Promise.all(paths.map((path) => {\n\t\t\tconst disposer = this.disposeMap.get(path);\n\t\t\tif (disposer) return disposer(this.dataMap.get(path));\n\t\t}));\n\t\tpaths.forEach((path) => {\n\t\t\tconst fn = this.pruneMap.get(path);\n\t\t\tif (fn) fn(this.dataMap.get(path));\n\t\t});\n\t}\n\twarnFailedUpdate(err, path) {\n\t\tif (!(err instanceof Error) || !err.message.includes(\"fetch\")) this.logger.error(err);\n\t\tthis.logger.error(`Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`);\n\t}\n\t/**\n\t* buffer multiple hot updates triggered by the same src change\n\t* so that they are invoked in the same order they were sent.\n\t* (otherwise the order may be inconsistent because of the http request round trip)\n\t*/\n\tasync queueUpdate(payload) {\n\t\tthis.updateQueue.push(this.fetchUpdate(payload));\n\t\tif (!this.pendingUpdateQueue) {\n\t\t\tthis.pendingUpdateQueue = true;\n\t\t\tawait Promise.resolve();\n\t\t\tthis.pendingUpdateQueue = false;\n\t\t\tconst loading = [...this.updateQueue];\n\t\t\tthis.updateQueue = [];\n\t\t\t(await Promise.all(loading)).forEach((fn) => fn && fn());\n\t\t}\n\t}\n\tasync fetchUpdate(update) {\n\t\tconst { path, acceptedPath, firstInvalidatedBy } = update;\n\t\tconst mod = this.hotModulesMap.get(path);\n\t\tif (!mod) return;\n\t\tlet fetchedModule;\n\t\tconst isSelfUpdate = path === acceptedPath;\n\t\tconst qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n\t\tif (isSelfUpdate || qualifiedCallbacks.length > 0) {\n\t\t\tconst disposer = this.disposeMap.get(acceptedPath);\n\t\t\tif (disposer) await disposer(this.dataMap.get(acceptedPath));\n\t\t\ttry {\n\t\t\t\tfetchedModule = await this.importUpdatedModule(update);\n\t\t\t} catch (e) {\n\t\t\t\tthis.warnFailedUpdate(e, acceptedPath);\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\ttry {\n\t\t\t\tthis.currentFirstInvalidatedBy = firstInvalidatedBy;\n\t\t\t\tfor (const { deps, fn } of qualifiedCallbacks) fn(deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0));\n\t\t\t\tconst loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n\t\t\t\tthis.logger.debug(`hot updated: ${loggedPath}`);\n\t\t\t} finally {\n\t\t\t\tthis.currentFirstInvalidatedBy = void 0;\n\t\t\t}\n\t\t};\n\t}\n};\n\n//#endregion\n//#region ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/non-secure/index.js\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet nanoid = (size = 21) => {\n\tlet id = \"\";\n\tlet i = size | 0;\n\twhile (i--) id += urlAlphabet[Math.random() * 64 | 0];\n\treturn id;\n};\n\n//#endregion\n//#region src/shared/constants.ts\nlet SOURCEMAPPING_URL = \"sourceMa\";\nSOURCEMAPPING_URL += \"ppingURL\";\n\n//#endregion\n//#region src/shared/utils.ts\nconst isWindows = typeof process !== \"undefined\" && process.platform === \"win32\";\nconst AsyncFunction = async function() {}.constructor;\nfunction promiseWithResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/shared/moduleRunnerTransport.ts\nfunction reviveInvokeError(e) {\n\tconst error = new Error(e.message || \"Unknown invoke error\");\n\tObject.assign(error, e, { runnerError: /* @__PURE__ */ new Error(\"RunnerError\") });\n\treturn error;\n}\nconst createInvokeableTransport = (transport$1) => {\n\tif (transport$1.invoke) return {\n\t\t...transport$1,\n\t\tasync invoke(name, data) {\n\t\t\tconst result = await transport$1.invoke({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tid: \"send\",\n\t\t\t\t\tname,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (\"error\" in result) throw reviveInvokeError(result.error);\n\t\t\treturn result.result;\n\t\t}\n\t};\n\tif (!transport$1.send || !transport$1.connect) throw new Error(\"transport must implement send and connect when invoke is not implemented\");\n\tconst rpcPromises = /* @__PURE__ */ new Map();\n\treturn {\n\t\t...transport$1,\n\t\tconnect({ onMessage, onDisconnection }) {\n\t\t\treturn transport$1.connect({\n\t\t\t\tonMessage(payload) {\n\t\t\t\t\tif (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n\t\t\t\t\t\tconst data = payload.data;\n\t\t\t\t\t\tif (data.id.startsWith(\"response:\")) {\n\t\t\t\t\t\t\tconst invokeId = data.id.slice(9);\n\t\t\t\t\t\t\tconst promise = rpcPromises.get(invokeId);\n\t\t\t\t\t\t\tif (!promise) return;\n\t\t\t\t\t\t\tif (promise.timeoutId) clearTimeout(promise.timeoutId);\n\t\t\t\t\t\t\trpcPromises.delete(invokeId);\n\t\t\t\t\t\t\tconst { error, result } = data.data;\n\t\t\t\t\t\t\tif (error) promise.reject(error);\n\t\t\t\t\t\t\telse promise.resolve(result);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tonMessage(payload);\n\t\t\t\t},\n\t\t\t\tonDisconnection\n\t\t\t});\n\t\t},\n\t\tdisconnect() {\n\t\t\trpcPromises.forEach((promise) => {\n\t\t\t\tpromise.reject(/* @__PURE__ */ new Error(`transport was disconnected, cannot call ${JSON.stringify(promise.name)}`));\n\t\t\t});\n\t\t\trpcPromises.clear();\n\t\t\treturn transport$1.disconnect?.();\n\t\t},\n\t\tsend(data) {\n\t\t\treturn transport$1.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tconst promiseId = nanoid();\n\t\t\tconst wrappedData = {\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:invoke\",\n\t\t\t\tdata: {\n\t\t\t\t\tname,\n\t\t\t\t\tid: `send:${promiseId}`,\n\t\t\t\t\tdata\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst sendPromise = transport$1.send(wrappedData);\n\t\t\tconst { promise, resolve, reject } = promiseWithResolvers();\n\t\t\tconst timeout = transport$1.timeout ?? 6e4;\n\t\t\tlet timeoutId;\n\t\t\tif (timeout > 0) {\n\t\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\t\treject(/* @__PURE__ */ new Error(`transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`));\n\t\t\t\t}, timeout);\n\t\t\t\ttimeoutId?.unref?.();\n\t\t\t}\n\t\t\trpcPromises.set(promiseId, {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\tname,\n\t\t\t\ttimeoutId\n\t\t\t});\n\t\t\tif (sendPromise) sendPromise.catch((err) => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\trpcPromises.delete(promiseId);\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\ttry {\n\t\t\t\treturn await promise;\n\t\t\t} catch (err) {\n\t\t\t\tthrow reviveInvokeError(err);\n\t\t\t}\n\t\t}\n\t};\n};\nconst normalizeModuleRunnerTransport = (transport$1) => {\n\tconst invokeableTransport = createInvokeableTransport(transport$1);\n\tlet isConnected = !invokeableTransport.connect;\n\tlet connectingPromise;\n\treturn {\n\t\t...transport$1,\n\t\t...invokeableTransport.connect ? { async connect(onMessage) {\n\t\t\tif (isConnected) return;\n\t\t\tif (connectingPromise) {\n\t\t\t\tawait connectingPromise;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst maybePromise = invokeableTransport.connect({\n\t\t\t\tonMessage: onMessage ?? (() => {}),\n\t\t\t\tonDisconnection() {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (maybePromise) {\n\t\t\t\tconnectingPromise = maybePromise;\n\t\t\t\tawait connectingPromise;\n\t\t\t\tconnectingPromise = void 0;\n\t\t\t}\n\t\t\tisConnected = true;\n\t\t} } : {},\n\t\t...invokeableTransport.disconnect ? { async disconnect() {\n\t\t\tif (!isConnected) return;\n\t\t\tif (connectingPromise) await connectingPromise;\n\t\t\tisConnected = false;\n\t\t\tawait invokeableTransport.disconnect();\n\t\t} } : {},\n\t\tasync send(data) {\n\t\t\tif (!invokeableTransport.send) return;\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"send was called before connect\");\n\t\t\tawait invokeableTransport.send(data);\n\t\t},\n\t\tasync invoke(name, data) {\n\t\t\tif (!isConnected) if (connectingPromise) await connectingPromise;\n\t\t\telse throw new Error(\"invoke was called before connect\");\n\t\t\treturn invokeableTransport.invoke(name, data);\n\t\t}\n\t};\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n\tconst pingInterval = options.pingInterval ?? 3e4;\n\tlet ws;\n\tlet pingIntervalId;\n\treturn {\n\t\tasync connect({ onMessage, onDisconnection }) {\n\t\t\tconst socket = options.createConnection();\n\t\t\tsocket.addEventListener(\"message\", async ({ data }) => {\n\t\t\t\tonMessage(JSON.parse(data));\n\t\t\t});\n\t\t\tlet isOpened = socket.readyState === socket.OPEN;\n\t\t\tif (!isOpened) await new Promise((resolve, reject) => {\n\t\t\t\tsocket.addEventListener(\"open\", () => {\n\t\t\t\t\tisOpened = true;\n\t\t\t\t\tresolve();\n\t\t\t\t}, { once: true });\n\t\t\t\tsocket.addEventListener(\"close\", async () => {\n\t\t\t\t\tif (!isOpened) {\n\t\t\t\t\t\treject(/* @__PURE__ */ new Error(\"WebSocket closed without opened.\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tonMessage({\n\t\t\t\t\t\ttype: \"custom\",\n\t\t\t\t\t\tevent: \"vite:ws:disconnect\",\n\t\t\t\t\t\tdata: { webSocket: socket }\n\t\t\t\t\t});\n\t\t\t\t\tonDisconnection();\n\t\t\t\t});\n\t\t\t});\n\t\t\tonMessage({\n\t\t\t\ttype: \"custom\",\n\t\t\t\tevent: \"vite:ws:connect\",\n\t\t\t\tdata: { webSocket: socket }\n\t\t\t});\n\t\t\tws = socket;\n\t\t\tpingIntervalId = setInterval(() => {\n\t\t\t\tif (socket.readyState === socket.OPEN) socket.send(JSON.stringify({ type: \"ping\" }));\n\t\t\t}, pingInterval);\n\t\t},\n\t\tdisconnect() {\n\t\t\tclearInterval(pingIntervalId);\n\t\t\tws?.close();\n\t\t},\n\t\tsend(data) {\n\t\t\tws.send(JSON.stringify(data));\n\t\t}\n\t};\n};\n\n//#endregion\n//#region src/shared/hmrHandler.ts\nfunction createHMRHandler(handler) {\n\tconst queue = new Queue();\n\treturn (payload) => queue.enqueue(() => handler(payload));\n}\nvar Queue = class {\n\tconstructor() {\n\t\t_defineProperty(this, \"queue\", []);\n\t\t_defineProperty(this, \"pending\", false);\n\t}\n\tenqueue(promise) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.queue.push({\n\t\t\t\tpromise,\n\t\t\t\tresolve,\n\t\t\t\treject\n\t\t\t});\n\t\t\tthis.dequeue();\n\t\t});\n\t}\n\tdequeue() {\n\t\tif (this.pending) return false;\n\t\tconst item = this.queue.shift();\n\t\tif (!item) return false;\n\t\tthis.pending = true;\n\t\titem.promise().then(item.resolve).catch(item.reject).finally(() => {\n\t\t\tthis.pending = false;\n\t\t\tthis.dequeue();\n\t\t});\n\t\treturn true;\n\t}\n};\n\n//#endregion\n//#region src/client/overlay.ts\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || \"/\";\nfunction h(e, attrs = {}, ...children) {\n\tconst elem = document.createElement(e);\n\tfor (const [k, v] of Object.entries(attrs)) elem.setAttribute(k, v);\n\telem.append(...children);\n\treturn elem;\n}\nconst templateStyle = `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\nconst createTemplate = () => h(\"div\", {\n\tclass: \"backdrop\",\n\tpart: \"backdrop\"\n}, h(\"div\", {\n\tclass: \"window\",\n\tpart: \"window\"\n}, h(\"pre\", {\n\tclass: \"message\",\n\tpart: \"message\"\n}, h(\"span\", {\n\tclass: \"plugin\",\n\tpart: \"plugin\"\n}), h(\"span\", {\n\tclass: \"message-body\",\n\tpart: \"message-body\"\n})), h(\"pre\", {\n\tclass: \"file\",\n\tpart: \"file\"\n}), h(\"pre\", {\n\tclass: \"frame\",\n\tpart: \"frame\"\n}), h(\"pre\", {\n\tclass: \"stack\",\n\tpart: \"stack\"\n}), h(\"div\", {\n\tclass: \"tip\",\n\tpart: \"tip\"\n}, \"Click outside, press \", h(\"kbd\", {}, \"Esc\"), \" key, or fix the code to dismiss.\", h(\"br\"), \"You can also disable this overlay by setting \", h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"), \" to \", h(\"code\", { part: \"config-option-value\" }, \"false\"), \" in \", h(\"code\", { part: \"config-file-name\" }, hmrConfigName), \".\")), h(\"style\", {}, templateStyle));\nconst fileRE = /(?:file:\\/\\/)?(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {} } = globalThis;\nvar ErrorOverlay = class extends HTMLElement {\n\tconstructor(err, links = true) {\n\t\tsuper();\n\t\t_defineProperty(this, \"root\", void 0);\n\t\t_defineProperty(this, \"closeOnEsc\", void 0);\n\t\tthis.root = this.attachShadow({ mode: \"open\" });\n\t\tthis.root.appendChild(createTemplate());\n\t\tcodeframeRE.lastIndex = 0;\n\t\tconst hasFrame = err.frame && codeframeRE.test(err.frame);\n\t\tconst message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n\t\tif (err.plugin) this.text(\".plugin\", `[plugin:${err.plugin}] `);\n\t\tthis.text(\".message-body\", message.trim());\n\t\tconst [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n\t\tif (err.loc) this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n\t\telse if (err.id) this.text(\".file\", file);\n\t\tif (hasFrame) this.text(\".frame\", err.frame.trim());\n\t\tthis.text(\".stack\", err.stack, links);\n\t\tthis.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n\t\t\te.stopPropagation();\n\t\t});\n\t\tthis.addEventListener(\"click\", () => {\n\t\t\tthis.close();\n\t\t});\n\t\tthis.closeOnEsc = (e) => {\n\t\t\tif (e.key === \"Escape\" || e.code === \"Escape\") this.close();\n\t\t};\n\t\tdocument.addEventListener(\"keydown\", this.closeOnEsc);\n\t}\n\ttext(selector, text, linkFiles = false) {\n\t\tconst el = this.root.querySelector(selector);\n\t\tif (!linkFiles) el.textContent = text;\n\t\telse {\n\t\t\tlet curIndex = 0;\n\t\t\tlet match;\n\t\t\tfileRE.lastIndex = 0;\n\t\t\twhile (match = fileRE.exec(text)) {\n\t\t\t\tconst { 0: file, index } = match;\n\t\t\t\tconst frag = text.slice(curIndex, index);\n\t\t\t\tel.appendChild(document.createTextNode(frag));\n\t\t\t\tconst link = document.createElement(\"a\");\n\t\t\t\tlink.textContent = file;\n\t\t\t\tlink.className = \"file-link\";\n\t\t\t\tlink.onclick = () => {\n\t\t\t\t\tfetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n\t\t\t\t};\n\t\t\t\tel.appendChild(link);\n\t\t\t\tcurIndex += frag.length + file.length;\n\t\t\t}\n\t\t\tif (curIndex < text.length) el.appendChild(document.createTextNode(text.slice(curIndex)));\n\t\t}\n\t}\n\tclose() {\n\t\tthis.parentNode?.removeChild(this);\n\t\tdocument.removeEventListener(\"keydown\", this.closeOnEsc);\n\t}\n};\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) customElements.define(overlayId, ErrorOverlay);\n\n//#endregion\n//#region src/client/client.ts\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = \"localhost:5173/\";\nconst socketProtocol = null || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:5173/\";\nconst base = \"/\" || \"/\";\nconst hmrTimeout = 30000;\nconst wsToken = \"-S4TfoOQXiZY\";\nconst transport = normalizeModuleRunnerTransport((() => {\n\tlet wsTransport = createWebSocketModuleRunnerTransport({\n\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${socketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\tpingInterval: hmrTimeout\n\t});\n\treturn {\n\t\tasync connect(handlers) {\n\t\t\ttry {\n\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t} catch (e) {\n\t\t\t\tif (!hmrPort) {\n\t\t\t\t\twsTransport = createWebSocketModuleRunnerTransport({\n\t\t\t\t\t\tcreateConnection: () => new WebSocket(`${socketProtocol}://${directSocketHost}?token=${wsToken}`, \"vite-hmr\"),\n\t\t\t\t\t\tpingInterval: hmrTimeout\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait wsTransport.connect(handlers);\n\t\t\t\t\t\tconsole.info(\"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\");\n\t\t\t\t\t} catch (e$1) {\n\t\t\t\t\t\tif (e$1 instanceof Error && e$1.message.includes(\"WebSocket closed without opened.\")) {\n\t\t\t\t\t\t\tconst currentScriptHostURL = new URL(import.meta.url);\n\t\t\t\t\t\t\tconst currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n\t\t\t\t\t\t\tconsole.error(`[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.error(`[vite] failed to connect to websocket (${e}). `);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\t\tasync disconnect() {\n\t\t\tawait wsTransport.disconnect();\n\t\t},\n\t\tsend(data) {\n\t\t\twsTransport.send(data);\n\t\t}\n\t};\n})());\nlet willUnload = false;\nif (typeof window !== \"undefined\") window.addEventListener(\"beforeunload\", () => {\n\twillUnload = true;\n});\nfunction cleanUrl(pathname) {\n\tconst url = new URL(pathname, \"http://vite.dev\");\n\turl.searchParams.delete(\"direct\");\n\treturn url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n\tlet timer;\n\treturn () => {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\t\ttimer = setTimeout(() => {\n\t\t\tlocation.reload();\n\t\t}, time);\n\t};\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient({\n\terror: (err) => console.error(\"[vite]\", err),\n\tdebug: (...msg) => console.debug(\"[vite]\", ...msg)\n}, transport, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport }) {\n\tconst [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n\tconst importPromise = import(\n\t/* @vite-ignore */\n\tbase + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`);\n\tif (isWithinCircularImport) importPromise.catch(() => {\n\t\tconsole.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n\t\tpageReload();\n\t});\n\treturn await importPromise;\n});\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n\tswitch (payload.type) {\n\t\tcase \"connected\":\n\t\t\tconsole.debug(`[vite] connected.`);\n\t\t\tbreak;\n\t\tcase \"update\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n\t\t\tif (hasDocument) if (isFirstUpdate && hasErrorOverlay()) {\n\t\t\t\tlocation.reload();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (enableOverlay) clearErrorOverlay();\n\t\t\t\tisFirstUpdate = false;\n\t\t\t}\n\t\t\tawait Promise.all(payload.updates.map(async (update) => {\n\t\t\t\tif (update.type === \"js-update\") return hmrClient.queueUpdate(update);\n\t\t\t\tconst { path, timestamp } = update;\n\t\t\t\tconst searchUrl = cleanUrl(path);\n\t\t\t\tconst el = Array.from(document.querySelectorAll(\"link\")).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n\t\t\t\tif (!el) return;\n\t\t\t\tconst newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tconst newLinkTag = el.cloneNode();\n\t\t\t\t\tnewLinkTag.href = new URL(newPath, el.href).href;\n\t\t\t\t\tconst removeOldEl = () => {\n\t\t\t\t\t\tel.remove();\n\t\t\t\t\t\tconsole.debug(`[vite] css hot updated: ${searchUrl}`);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t};\n\t\t\t\t\tnewLinkTag.addEventListener(\"load\", removeOldEl);\n\t\t\t\t\tnewLinkTag.addEventListener(\"error\", removeOldEl);\n\t\t\t\t\toutdatedLinkTags.add(el);\n\t\t\t\t\tel.after(newLinkTag);\n\t\t\t\t});\n\t\t\t}));\n\t\t\tawait hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n\t\t\tbreak;\n\t\tcase \"custom\": {\n\t\t\tawait hmrClient.notifyListeners(payload.event, payload.data);\n\t\t\tif (payload.event === \"vite:ws:disconnect\") {\n\t\t\t\tif (hasDocument && !willUnload) {\n\t\t\t\t\tconsole.log(`[vite] server connection lost. Polling for restart...`);\n\t\t\t\t\tconst socket = payload.data.webSocket;\n\t\t\t\t\tconst url = new URL(socket.url);\n\t\t\t\t\turl.search = \"\";\n\t\t\t\t\tawait waitForSuccessfulPing(url.href);\n\t\t\t\t\tlocation.reload();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"full-reload\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n\t\t\tif (hasDocument) if (payload.path && payload.path.endsWith(\".html\")) {\n\t\t\t\tconst pagePath = decodeURI(location.pathname);\n\t\t\t\tconst payloadPath = base + payload.path.slice(1);\n\t\t\t\tif (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) pageReload();\n\t\t\t\treturn;\n\t\t\t} else pageReload();\n\t\t\tbreak;\n\t\tcase \"prune\":\n\t\t\tawait hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n\t\t\tawait hmrClient.prunePaths(payload.paths);\n\t\t\tbreak;\n\t\tcase \"error\": {\n\t\t\tawait hmrClient.notifyListeners(\"vite:error\", payload);\n\t\t\tif (hasDocument) {\n\t\t\t\tconst err = payload.err;\n\t\t\t\tif (enableOverlay) createErrorOverlay(err);\n\t\t\t\telse console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"ping\": break;\n\t\tdefault: {\n\t\t\tconst check = payload;\n\t\t\treturn check;\n\t\t}\n\t}\n}\nconst enableOverlay = true;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n\tclearErrorOverlay();\n\tconst { customElements: customElements$1 } = globalThis;\n\tif (customElements$1) {\n\t\tconst ErrorOverlayConstructor = customElements$1.get(overlayId);\n\t\tdocument.body.appendChild(new ErrorOverlayConstructor(err));\n\t}\n}\nfunction clearErrorOverlay() {\n\tdocument.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n\treturn document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n\tasync function ping() {\n\t\tconst socket = new WebSocket(socketUrl, \"vite-ping\");\n\t\treturn new Promise((resolve) => {\n\t\t\tfunction onOpen() {\n\t\t\t\tresolve(true);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction onError() {\n\t\t\t\tresolve(false);\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tfunction close() {\n\t\t\t\tsocket.removeEventListener(\"open\", onOpen);\n\t\t\t\tsocket.removeEventListener(\"error\", onError);\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t\tsocket.addEventListener(\"open\", onOpen);\n\t\t\tsocket.addEventListener(\"error\", onError);\n\t\t});\n\t}\n\tif (await ping()) return;\n\tawait wait(ms);\n\twhile (true) if (document.visibilityState === \"visible\") {\n\t\tif (await ping()) break;\n\t\tawait wait(ms);\n\t} else await waitForWindowShow();\n}\nfunction wait(ms) {\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n\treturn new Promise((resolve) => {\n\t\tconst onChange = async () => {\n\t\t\tif (document.visibilityState === \"visible\") {\n\t\t\t\tresolve();\n\t\t\t\tdocument.removeEventListener(\"visibilitychange\", onChange);\n\t\t\t}\n\t\t};\n\t\tdocument.addEventListener(\"visibilitychange\", onChange);\n\t});\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n\tsheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n});\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n\tlet style = sheetsMap.get(id);\n\tif (!style) {\n\t\tstyle = document.createElement(\"style\");\n\t\tstyle.setAttribute(\"type\", \"text/css\");\n\t\tstyle.setAttribute(\"data-vite-dev-id\", id);\n\t\tstyle.textContent = content;\n\t\tif (cspNonce) style.setAttribute(\"nonce\", cspNonce);\n\t\tif (!lastInsertedStyle) {\n\t\t\tdocument.head.appendChild(style);\n\t\t\tsetTimeout(() => {\n\t\t\t\tlastInsertedStyle = void 0;\n\t\t\t}, 0);\n\t\t} else lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n\t\tlastInsertedStyle = style;\n\t} else style.textContent = content;\n\tsheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n\tconst style = sheetsMap.get(id);\n\tif (style) {\n\t\tdocument.head.removeChild(style);\n\t\tsheetsMap.delete(id);\n\t}\n}\nfunction createHotContext(ownerPath) {\n\treturn new HMRContext(hmrClient, ownerPath);\n}\n/**\n* urls here are dynamic import() urls that couldn't be statically analyzed\n*/\nfunction injectQuery(url, queryToInject) {\n\tif (url[0] !== \".\" && url[0] !== \"/\") return url;\n\tconst pathname = url.replace(/[?#].*$/, \"\");\n\tconst { search, hash } = new URL(url, \"http://vite.dev\");\n\treturn `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\n//#endregion\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };",
      "start": 1751213799881,
      "end": 1751213799882,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
